/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/server.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app/controllers/dropdown/index.jsx":
/*!************************************************!*\
  !*** ./src/app/controllers/dropdown/index.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _style = __webpack_require__(/*! ./style.scss */ "./src/app/controllers/dropdown/style.scss");

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// magic-strings
const NAMESPACE = {
  eventList: ['click', 'scroll'],
  className: {
    leader: '_-dropdown',
    toggle: '_-dropdown__toggle',
    target: '_-dropdown__menu',
    hidden: '_-dropdown__menu_hidden'
  }
};

// components


// styles
class Dropdown extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.dropdownBoxClassName = [NAMESPACE.className.leader, this.props.className].join(' ').trim(), this.dropdownBox = _react2.default.createRef(), this.componentDidMount = () => {
      const { className } = NAMESPACE;
      this.dropdownMenuNode = this.dropdownBox.current.getElementsByClassName(className.target)[0];
      this.dropdownMenuNode.classList.add(className.hidden);
    }, this._handleDropdownEvent = e => {
      const { className, eventList } = NAMESPACE;
      if (!e.target.className || !e.target.className.includes(className.target)) {
        this.dropdownMenuNode.classList.add(className.hidden);
        eventList.map(type => document.removeEventListener(type, this._handleDropdownEvent));
      }
    }, this._onClickToggleMenu = e => {
      const { className, eventList } = NAMESPACE;
      e.target.className.includes(className.toggle) && !this.dropdownMenuNode.classList.toggle(className.hidden) && eventList.map(type => document.addEventListener(type, this._handleDropdownEvent));
    }, this.render = () => _react2.default.createElement(
      'div',
      { className: this.dropdownBoxClassName, ref: this.dropdownBox, onClick: this._onClickToggleMenu },
      this.props.children
    ), _temp;
  }

}

// exports
exports.default = Dropdown;

/***/ }),

/***/ "./src/app/controllers/dropdown/style.scss":
/*!*************************************************!*\
  !*** ./src/app/controllers/dropdown/style.scss ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/app/controllers/sticky/index.jsx":
/*!**********************************************!*\
  !*** ./src/app/controllers/sticky/index.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _style = __webpack_require__(/*! ./style.scss */ "./src/app/controllers/sticky/style.scss");

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// magic-strings
const NAMESPACE = {
  eventList: ['resize', 'scroll'],
  className: {
    leader: '_-sticky',
    navbar: '_-sticky_navbar',
    active: '_-sticky_active',
    hauled: '_-sticky_hauled'
  }
};

// helpers


// style
const getScaledValue = function getScaledValue(value, scaleFactor) {
  const parse = /^(-?\d+)?(?:.(\d+))?(%|px)?$/.exec(`${value}`.trim()) || {};
  return parse[3] === '%' ? +`${parse[1] || 0}.${parse[2] || 0}` / 100 * (scaleFactor || 1) : +parse[1];
};

const getQuantityUponBaseline = function getQuantityUponBaseline(num, baseline) {
  return Math.floor(num < 0 ? baseline > -num ? baseline + num : 0 : num);
};

const scrollPosition = function scrollPosition() {
  return Math.max(document.documentElement.scrollTop, document.body.scrollTop, window.pageYOffset);
};

// components
class Sticky extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.stickyBoxClassNames = [NAMESPACE.className.leader, this.props.className].join(' ').trim(), this.stickyBox = _react2.default.createRef(), this._loadConfigs = () => {
      this.stickyBoxNode = this.stickyBox.current;
      this.stickyConfigs = {
        $TOP: getScaledValue(this.props.top, window.innerHeight),
        $BOTTOM: getScaledValue(this.props.bottom, window.innerHeight),
        $START: getScaledValue(this.props.start, document.documentElement.scrollHeight),
        $STOP: getScaledValue(this.props.stop, document.documentElement.scrollHeight),
        $DISTANCE: getScaledValue(this.props.distance, document.documentElement.scrollHeight)
      };
      return this;
    }, this._updateStickyBox = () => {
      this.stickyBoxNode.style.height = this.stickyBoxNode.style.width = '';
      this.stickyBoxNode.style.height = `${this.stickyBoxNode.offsetHeight}px`;
      this.stickyBoxNode.style.width = `${this.stickyBoxNode.offsetWidth}px`;
      return this;
    }, this._calculatePositions = () => {
      const { $TOP, $BOTTOM, $START, $STOP, $DISTANCE } = this.stickyConfigs;

      // calculating positions
      const initial = this.stickyBoxNode.getBoundingClientRect().top + scrollPosition();
      const vertex = getQuantityUponBaseline($TOP) // by $TOP
      || getQuantityUponBaseline(-$BOTTOM, window.innerHeight) // by $BOTTOM
      || getQuantityUponBaseline($START - initial) // by $START
      || (initial ? -initial : 0); // (default, non-sticky)
      const active = getQuantityUponBaseline(initial - vertex) + (initial ? 0 : this.stickyBoxNode.offsetHeight);
      const frozen = getQuantityUponBaseline($STOP, document.documentElement.scrollHeight) // by $STOP
      || active + (getQuantityUponBaseline($DISTANCE) || document.documentElement.scrollHeight); // by $DISTANCE (default, endless)

      // exposing the results
      this.stickyPositions = { initial, vertex, active, frozen };

      return this;
    }, this._updateStickyElement = () => {
      const { className } = NAMESPACE;
      const { initial, vertex, active, frozen } = this.stickyPositions;
      const current = scrollPosition();

      // assigning classNames
      if (active < current && initial === 0) this.stickyBoxNode.classList.add(className.navbar);
      if (active < current) this.stickyBoxNode.classList.add(className.active, className.hauled);
      if (active >= current) {
        this.stickyBoxNode.classList.remove(className.active, className.hauled, className.navbar);
        this.stickyBoxNode.style.top = '';
      } else if (active < current && current <= frozen) {
        this.stickyBoxNode.style.top = `${vertex}px`;
      } else {
        this.stickyBoxNode.classList.remove(className.active);
        this.stickyBoxNode.style.top = `${frozen - active}px`;
      }

      return this;
    }, this._handleStickyEvent = e => {
      if (e.type === 'resize') this._updateStickyBox()._calculatePositions()._updateStickyElement();
      if (e.type === 'scroll') this._updateStickyElement();
    }, this.componentDidMount = () => {
      const { eventList } = NAMESPACE;
      this._loadConfigs()._updateStickyBox()._calculatePositions()._updateStickyElement();
      eventList.map(type => window.addEventListener(type, this._handleStickyEvent));
    }, this.componentWillUnmount = () => {
      const { eventList } = NAMESPACE;
      eventList.map(type => window.removeEventListener(type, this._handleStickyEvent));
    }, this.render = () => _react2.default.createElement(
      'div',
      { className: this.stickyBoxClassNames, ref: this.stickyBox },
      this.props.children
    ), _temp;
  }

}

// exports
exports.default = Sticky;

/***/ }),

/***/ "./src/app/controllers/sticky/style.scss":
/*!***********************************************!*\
  !*** ./src/app/controllers/sticky/style.scss ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/app/index.jsx":
/*!***************************!*\
  !*** ./src/app/index.jsx ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(/*! react-router-dom */ "react-router-dom");

var _routers = __webpack_require__(/*! ./routers/ */ "./src/app/routers/index.jsx");

var _navbar = __webpack_require__(/*! ./views/navbar */ "./src/app/views/navbar.jsx");

var _navbar2 = _interopRequireDefault(_navbar);

var _footer = __webpack_require__(/*! ./views/footer */ "./src/app/views/footer.jsx");

var _footer2 = _interopRequireDefault(_footer);

var _unfounded = __webpack_require__(/*! ./routers/unfounded */ "./src/app/routers/unfounded.jsx");

var _unfounded2 = _interopRequireDefault(_unfounded);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

// routing


// blocks


// components
const App = () => _react2.default.createElement(
  'div',
  null,
  _react2.default.createElement(_navbar2.default, null),
  _react2.default.createElement(
    'div',
    { className: 'container' },
    _react2.default.createElement(
      _reactRouterDom.Switch,
      null,
      _routers.routers.map((_ref) => {
        let { path, exact, component: C } = _ref,
            rest = _objectWithoutProperties(_ref, ['path', 'exact', 'component']);

        return _react2.default.createElement(_reactRouterDom.Route, { key: path, path: path, exact: exact, render: props => _react2.default.createElement(C, _extends({}, props, rest)) });
      }),
      _react2.default.createElement(_reactRouterDom.Route, { render: props => _react2.default.createElement(_unfounded2.default, props) })
    )
  ),
  _react2.default.createElement(_footer2.default, null)
);

// exports
exports.default = App;

/***/ }),

/***/ "./src/app/render.jsx":
/*!****************************!*\
  !*** ./src/app/render.jsx ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderClient = exports.renderServer = undefined;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(/*! react-router-dom */ "react-router-dom");

var _ = __webpack_require__(/*! ./ */ "./src/app/index.jsx");

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// markups
const renderServer = (location, data) => _react2.default.createElement(
  _reactRouterDom.StaticRouter,
  { location: location, context: data },
  _react2.default.createElement(_2.default, null)
);

const renderClient = () => _react2.default.createElement(
  _reactRouterDom.BrowserRouter,
  null,
  _react2.default.createElement(_2.default, null)
);

// exports
exports.renderServer = renderServer;
exports.renderClient = renderClient;

/***/ }),

/***/ "./src/app/routers/blog.jsx":
/*!**********************************!*\
  !*** ./src/app/routers/blog.jsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _postlist = __webpack_require__(/*! ../views/postlist */ "./src/app/views/postlist/index.jsx");

var _postlist2 = _interopRequireDefault(_postlist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components
/* global __isBrowser__ */
class Blog extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = {
      data:  false ? undefined : this.props.staticContext,
      loading: false
    }, _temp;
  }

  loadData(url) {
    this.setState(() => ({ loading: true }));
    this.props.fetch(url).then(data => this.setState(() => ({ data, loading: false })));
  }

  componentDidMount() {
    if (!this.state.data) this.loadData(this.props.match.url);
  }

  render() {
    // if (__isBrowser__) delete window.__INIT__;
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement(_postlist2.default, this.state.data)
    );
  }
}

// exports
exports.default = Blog;

/***/ }),

/***/ "./src/app/routers/index.jsx":
/*!***********************************!*\
  !*** ./src/app/routers/index.jsx ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.routers = exports.default = undefined;

var _https = __webpack_require__(/*! https */ "https");

var _https2 = _interopRequireDefault(_https);

var _nodeFetch = __webpack_require__(/*! node-fetch */ "node-fetch");

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

var _blog = __webpack_require__(/*! ../routers/blog */ "./src/app/routers/blog.jsx");

var _blog2 = _interopRequireDefault(_blog);

var _landing = __webpack_require__(/*! ../routers/landing */ "./src/app/routers/landing.jsx");

var _landing2 = _interopRequireDefault(_landing);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components
const index = [{
  path: '/blog',
  exact: true,
  component: _blog2.default,
  fetch: path => (0, _nodeFetch2.default)(`https://localhost:3443/api${path}`, { agent: new _https2.default.Agent({ rejectUnauthorized: false }) }).then(res => res.json())
}, {
  path: '/',
  exact: true,
  component: _landing2.default
}];

exports.default = index;
exports.routers = index;

/***/ }),

/***/ "./src/app/routers/landing.jsx":
/*!*************************************!*\
  !*** ./src/app/routers/landing.jsx ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components
const Landing = () => _react2.default.createElement(
  'div',
  null,
  'LAND'
);

// exports
exports.default = Landing;

/***/ }),

/***/ "./src/app/routers/unfounded.jsx":
/*!***************************************!*\
  !*** ./src/app/routers/unfounded.jsx ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components
const Unfounded = () => _react2.default.createElement(
  'div',
  null,
  _react2.default.createElement(
    'p',
    null,
    'Recourse Unfounded'
  )
);

// exports
exports.default = Unfounded;

/***/ }),

/***/ "./src/app/views/footer.jsx":
/*!**********************************!*\
  !*** ./src/app/views/footer.jsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components
const Footer = () => _react2.default.createElement(
  "footer",
  { className: "mt-5 _-footer" },
  "\xA0"
);

// exports
exports.default = Footer;

/***/ }),

/***/ "./src/app/views/navbar.jsx":
/*!**********************************!*\
  !*** ./src/app/views/navbar.jsx ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(/*! react-router-dom */ "react-router-dom");

var _sticky = __webpack_require__(/*! ../controllers/sticky/ */ "./src/app/controllers/sticky/index.jsx");

var _sticky2 = _interopRequireDefault(_sticky);

var _dropdown = __webpack_require__(/*! ../controllers/dropdown/ */ "./src/app/controllers/dropdown/index.jsx");

var _dropdown2 = _interopRequireDefault(_dropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// components


// dependents
const Brand = () => _react2.default.createElement(
  _reactRouterDom.NavLink,
  { className: 'navbar-brand mb-0 h1', to: '/' },
  'SandBox'
);

const UserMenu = () => _react2.default.createElement(
  _dropdown2.default,
  null,
  _react2.default.createElement(
    'div',
    { className: '_-dropdown__toggle' },
    _react2.default.createElement('img', {
      alt: 'user menu',
      className: '_-dropdown__toggle__icon',
      src: 'https://localhost:3443/static/media/icon.png'
    })
  ),
  _react2.default.createElement(
    'div',
    { className: '_-dropdown__menu _-dropdown__menu_hidden' },
    _react2.default.createElement(
      'ul',
      { className: '_-dropdown__menu__box' },
      _react2.default.createElement(
        'li',
        { className: '_-dropdown__menu__item--title' },
        'Hi ...!'
      ),
      _react2.default.createElement(
        'li',
        { className: '_-dropdown__menu__item--divider' },
        '\xA0'
      ),
      _react2.default.createElement(
        _reactRouterDom.NavLink,
        { to: '/blog' },
        _react2.default.createElement(
          'li',
          { className: '_-dropdown__menu__item' },
          'BLOG'
        )
      ),
      _react2.default.createElement(
        'li',
        { className: '_-dropdown__menu__item--divider' },
        '\xA0'
      ),
      _react2.default.createElement(
        'li',
        { className: '_-dropdown__menu__item' },
        '...'
      )
    )
  )
);

const NavBar = () => _react2.default.createElement(
  _sticky2.default,
  null,
  _react2.default.createElement(
    'nav',
    { className: 'navbar navbar-expand-lg _-nav' },
    _react2.default.createElement(
      'div',
      { className: 'container' },
      _react2.default.createElement(Brand, null),
      _react2.default.createElement(UserMenu, null)
    )
  )
);

// exports
exports.default = NavBar;

/***/ }),

/***/ "./src/app/views/postlist/index.jsx":
/*!******************************************!*\
  !*** ./src/app/views/postlist/index.jsx ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
const React = __webpack_require__(/*! react */ "react");

// components
const Post = ({ post: { _id, title, author, category, time } }) => React.createElement(
  "article",
  { className: "col-9", id: _id },
  React.createElement(
    "h2",
    null,
    title
  ),
  React.createElement(
    "header",
    { className: "row" },
    React.createElement(
      "div",
      { className: "col-md-9" },
      author.nickname,
      " | ",
      category
    ),
    React.createElement(
      "time",
      { className: "col-md-3 text-lg-right", dateTime: time._created },
      time._created
    )
  )
);

const PostList = ({ list = [] }) => React.createElement(
  "div",
  { className: "container" },
  list.length > 0 && list.map(post => React.createElement(Post, { key: post._id, post: post }))
);

// exports
exports.default = PostList;

/***/ }),

/***/ "./src/server/app.js":
/*!***************************!*\
  !*** ./src/server/app.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const qs = __webpack_require__(/*! qs */ "qs");
const session = __webpack_require__(/*! express-session */ "express-session");
const favicon = __webpack_require__(/*! serve-favicon */ "serve-favicon");
const logger = __webpack_require__(/*! morgan */ "morgan");
const MongoStore = __webpack_require__(/*! connect-mongo */ "connect-mongo")(session);
const bodyParser = __webpack_require__(/*! body-parser */ "body-parser");
const mongoose = __webpack_require__(/*! mongoose */ "mongoose");
const express = __webpack_require__(/*! express */ "express");
const path = __webpack_require__(/*! path */ "path");
const passport = __webpack_require__(/*! passport */ "passport");
const flash = __webpack_require__(/*! connect-flash */ "connect-flash");


// MODULE
const { _M_ } = __webpack_require__(/*! ./controllers/modules/ */ "./src/server/controllers/modules/index.js");
const { _U_ } = __webpack_require__(/*! ./controllers/utilities/ */ "./src/server/controllers/utilities/index.js");
const { ConfigsModel, UsersModel } = __webpack_require__(/*! ./models/ */ "./src/server/models/index.js");
const { serverSideRendering } = __webpack_require__(/*! ./engines/view */ "./src/server/engines/view.js");
const routingService = __webpack_require__(/*! ./routers/ */ "./src/server/routers/index.js");
const securityHeaderAgent = __webpack_require__(/*! ./services/security */ "./src/server/services/security.js");
const errorHandlingAgent = __webpack_require__(/*! ./services/error */ "./src/server/services/error.js");


// CONNECTION
const app = express();


/** setting **/
app.set('env', 'development');
app.set('query parser', str => {
  return _U_.object.burstArrayDeep(qs.parse(str, { parseArrays: false, depth: 0 }), { mutate: true, position: -1 });
});


/** database **/
mongoose.connect(process.env.DB).then(() => ConfigsModel.initConfig(app));


/** security **/
securityHeaderAgent(app);


/** static public resources **/
app.set('upload', path.resolve('./static/public/media'));
app.use('/static', express.static(path.resolve('./static/public'), {
  setHeaders: (res) => res.set('x-robots-tag', 'none'),
}));


/** session **/
app.use(session({
  name: '__SESSION__',
  secret: process.env.SECRET,
  saveUninitialized: false,
  resave: false,
  cookie: ( false) ? undefined : { secure: true, httpOnly: true },                                    // note: secure === true only allows HTTPS and leading to test fail
  store: new MongoStore({
    mongooseConnection: mongoose.connection,
    autoRemove: 'native',
  }),
}));


/** passport **/
passport.use(UsersModel.createStrategy());
passport.serializeUser(UsersModel.serializeUser());
passport.deserializeUser(UsersModel.deserializeUser());


/** static private resources **/
app.use('/static', _M_.isSignedIn, express.static(path.resolve('./static/private'), {
  setHeaders: (res) => res.set('x-robots-tag', 'none'),
}));


/** debugger **/
if (true) app.use(logger('dev'));


/** API **/
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json({ type: 'application/json' }));
app.use('/api', routingService('API'));


/** HTML **/
app.use(flash());
app.use(favicon(path.resolve('./static/public/media', 'favicon.ico')));
app.use(serverSideRendering);


/** error **/
errorHandlingAgent(app);


// exports
module.exports = ( false) ? undefined : app;


/***/ }),

/***/ "./src/server/controllers/handlers/error.js":
/*!**************************************************!*\
  !*** ./src/server/controllers/handlers/error.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");


// redirect
const redirect = {};

/**
 * redirect to sign-in page
 */
redirect.signInRetry = function signInRetry(req, res) {
  if (req.header('Referrer') && req.header('Referrer').includes(req.originalUrl)) {
    res.locals.$$VIEW.flash.info.forEach(info => req.flash('info', info));
    delete req.flash('error');
  }
  req.session.returnTo = req.originalUrl;
  req.flash('action', 'retry');
  return res.redirect('/signin');
};

// todo: redirect.persistForm


// terminals
const terminal = {};

terminal.ClientException = function ClientException(err, req, res, next) {
  if (!err.from && err.code === 20000) return redirect.signInRetry(req, res);
  switch (err.from) {
    case 'BulkWriteError':
      if (err.code === 11000) req.flash('error', 'This username is not available.');
      return res.redirect('back');
    case 'UserExistsError':
      req.flash('error', 'This email have been used.');
      break;
    case 'ValidationError':
    default: {
      req.flash('error', err.message);
    }
  }
  return res.redirect('back');
};


terminal.TemplateException = function TemplateException(err, req, res, next) {
  return res.status(500).render('./theme/error', { err });                                                              // todo: log the message and call the admin
};


terminal.HttpException = function HttpException(err, req, res, next) {
  return res.status(err.code).render('./theme/error', { err });
};


// control
const exceptionHandler = function exceptionHandler(err, req, res, next) {
  if (['development', 'test'].includes("development")) console.log(err.stack);

  return _M_.noCrawlerHeader(req, res, () => {
    if (terminal[err.name]) return terminal[err.name](err, req, res, next);
    return res.render('./theme/error', { err });
  });
};


// exports
module.exports = {
  exceptionHandler,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    redirect,
    terminal,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/handlers/exporter.js":
/*!*****************************************************!*\
  !*** ./src/server/controllers/handlers/exporter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _U_ } = __webpack_require__(/*! ../utilities/ */ "./src/server/controllers/utilities/index.js");
const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");


// magic-strings
const VIEW_POSTS_SINGLE = Symbol('VIEW_POSTS_SINGLE');
const VIEW_POSTS_MULTIPLE = Symbol('VIEW_POSTS_MULTIPLE');
const VIEW_STACK = Symbol('VIEW_STACK');


// renderer
const renderer = { posts: {} };

/**
 * #(factory) handle a single post document
 * @param {string} filename                 - template name
 * @param {object} [post]                   - post document
 * @param {object} [meta]                   - meta object
 * @return {string|*}
 */
renderer.posts.single = ({ filename, post = null, meta = {} } = {}) => function singlePostRenderer(req, res) {
  if (!post
      || (!post.state || post.state.recycled)
      || (!post.state.published && !req.session.user)                                                                   // todo: wired up with authorization
  ) throw new _U_.error.HttpException(404);
  if (post.title) _M_.modifyHTMLTitleTag({ tag: post.title, extend: false })(req, res);
  return res.render(filename, { $$POST: post, $$META: meta });
};


/**
 * #(factory) handle a multiple post document list
 * @param {string} filename                 - template name
 * @param {array} [list]                    - list of post documents
 * @param {object} [meta]                   - meta object
 * @return {string|*}
 */
renderer.posts.multiple = ({ filename, list = [], meta = {} } = {}) => function multiplePostRenderer(req, res) {
  const paginatedURL = `${res.locals.$$VIEW.route}?num=${meta.num}&page='`;
  if (meta.now > 1) res.locals.$$VIEW.prev = paginatedURL + (meta.now - 1);
  if (meta.now < meta.end) res.locals.$$VIEW.next = paginatedURL + (meta.now + 1);
  return res.render(filename, { $$LIST: list, $$META: meta });
};


/**
 * (factory) export HTML string via proper renderer
 * @param {string} [$template]              - template name
 * @param {symbol} [$renderer]              - renderer symbol
 * @return {string|*}
 */
const exportHTML = ({ template: $template, renderer: $renderer } = {}) => function templateHandler(req, res) {
  const { post, list, meta, template = $template, renderer: renderingSymbol = $renderer } = req.session.cache
    ? req.session.cache
    : {};
  delete req.session.cache;

  // check dynamic template
  const filename = template && template.replace(/\/:([\w\d$-]+)$/i, (match, key) => `/${req.params[key]}`);
  if (!filename) throw new ReferenceError('Missing template');

  switch (renderingSymbol) {
    case VIEW_POSTS_SINGLE:
      return renderer.posts.single({ filename, post, meta })(req, res);
    case VIEW_POSTS_MULTIPLE:
    case VIEW_STACK:
      return renderer.posts.multiple({ filename, list, meta })(req, res);
    default: {
      return res.render(filename);
    }
  }
};


/**
 * (factory) export json document
 * @param {object} option                  - option (place holder)
 * @return {JSON|*}
 */
const exportJSON = (option) => function JSONHandler(req, res) {
  const doc = {
    ...(req.session.cache ? req.session.cache : {}),
    _execution_time: new Date(Date.now()).toISOString(),
    _cache: false,
  };
  delete req.session.cache;
  return res.json(doc);
};


// exports
module.exports = {
  exportHTML,
  exportJSON,
  rendererSymbols: {
    VIEW_POSTS_SINGLE,
    VIEW_POSTS_MULTIPLE,
    VIEW_STACK,
  },
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    renderer,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/handlers/receptor.js":
/*!*****************************************************!*\
  !*** ./src/server/controllers/handlers/receptor.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * start to handle any request
 */
const initialReceptor = (req, res, next) => {
  res.locals.$$SITE = req.app.get('APP_CONFIG');
  if (!res.locals.$$SITE.initialized && !req.url.match(/^\/init/i)) return res.redirect('/init');
  return next();
};


/**
 * start to handle an HTML(browser) request
 */
const browserReceptor = (req, res, next) => {                                                                           // todo: start to load template file from fs? (concurrency)
  // populating variables
  res.locals.$$MODE = 'HTML';
  res.locals.$$VIEW = {
    flash: { error: req.flash('error'), info: req.flash('info'), action: req.flash('action') },
    route: req.baseUrl + req.path,
    title: res.locals.$$SITE.title,
    user: req.session.user,
    params: req.params,
    query: req.query,
  };

  // housekeeping sessions
  if (res.locals.$$VIEW.flash.action[0] !== 'retry') delete req.session.returnTo;

  return next();
  // return req.body.post && ['POST', 'PATCH'].includes(req.method) ? _M_.postNormalizer(req, res, next) : next();      // tofix: move to other place
};


/**
 * start to handle an API request
 */
const APIReceptor = (req, res, next) => {
  // populate variables
  res.locals.$$MODE = 'API';

  // setup required headers
  res.set('Access-Control-Allow-Origin', '*');                                                                          // todo: set to allowed domain list
  res.set('Access-Control-Allow-Methods', 'GET, PUT, HEAD, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control');
  // res.set('Access-Control-Allow-Credentials', 'true');
  res.set('Access-Control-Max-Age', '600');

  return next();
};


// exports
module.exports = { initialReceptor, browserReceptor, APIReceptor };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/auth.js":
/*!************************************************!*\
  !*** ./src/server/controllers/modules/auth.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const passport = __webpack_require__(/*! passport */ "passport");
const { _U_ } = __webpack_require__(/*! ../utilities/ */ "./src/server/controllers/utilities/index.js");
const { PostsModel } = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");
const { noCrawlerHeader } = __webpack_require__(/*! ./header */ "./src/server/controllers/modules/header.js");


/**
 * (plugin) use passport to populate `req.user`
 */
const usePassport = [noCrawlerHeader, passport.initialize(), passport.session()];


/**
 * validate if client is authenticated
 */
const isSignedIn = [...usePassport, function isSignedIn(req, res, next) {
  if (!(req.isAuthenticated() && req.session.user)) throw new _U_.error.ClientException(20000);
  return next();
}];


/**
 * validate if client is authorized
 */
const isAuthorized = [...isSignedIn, async function isAuthorized(req, res, next) {
  const [field, val] = req.params.canonical
    ? ['canonical', req.params.canonical]
    : ['_id', _U_.string.parseMongoObjectId(req.url)];
  if (await PostsModel.count({ [field]: val, 'author._id': req.user._id }) !== 1) {                                     // tofix: find the post first then decide to give or not
    throw new _U_.error.ClientException(20001);
  }
  return next();
}];


/**
 * validate if resetting password is acceptable
 */
const isValidPasswordSyntax = (req, res, next) => {
  const { password } = req.body;
  if (password.old === '' || !password.new || !password.confirmed) throw new _U_.error.ClientException(10001);
  if (password.new !== password.confirmed) throw new _U_.error.ClientException(10002);
  if (password.new === password.old) throw new _U_.error.ClientException(10003);
  return next();
};


// exports
module.exports = {
  usePassport,
  isSignedIn,
  isAuthorized,
  isValidPasswordSyntax,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/header.js":
/*!**************************************************!*\
  !*** ./src/server/controllers/modules/header.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * prevent from parsing by crawlers
 */
const noCrawlerHeader = function noCrawlerHeader(req, res, next) {
  res.set('Cache-Control', 'private, max-age=0');
  res.set('x-robots-tag', 'none');
  if (typeof next === 'function') return next();
};


/**
 * prevent data storage from caches
 */
const noStoreCacheHeader = function noStoreCacheHeader(req, res, next) {
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate');
  if (typeof next === 'function') return next();
};


// exports
module.exports = {
  noCrawlerHeader,
  noStoreCacheHeader,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/helper.js":
/*!**************************************************!*\
  !*** ./src/server/controllers/modules/helper.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _U_ } = __webpack_require__(/*! ../utilities/ */ "./src/server/controllers/utilities/index.js");
const { PostsModel } = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");


/**
 * allow case insensitive accessing of `req.query`
 */
const caseInsensitiveQueryProxy = (req, res, next) => {
  req.query = _U_.object.createCaseInsensitiveProxy(req.query);
  return next();
};


/**
 * modify HTML title tag
 * @param {object|string} option            - modifying options
 * @param {string} option.tag               - title substring
 * @param {boolean} [option.extend = true]  - replace the whole string
 * @param {boolean} [option.append = false] - append title tag
 * @param {string} [option.delimiter = '-'] - delimiter used in conjunction
 */
const modifyHTMLTitleTag = (option) => function modifyHTMLTitleTagByOption(req, res, next) {
  if (res.locals.$$MODE === 'HTML') {
    const config = (_U_.string.checkToStringTag(option, 'String')) ? { tag: option } : option;
    const { tag, extend = true, append = false, delimiter = '-' } = config;

    // populate sequence
    const sequence = [];
    if (extend !== false) sequence.push(res.locals.$$VIEW.title);
    if (append === true) sequence.push(tag);
    else sequence.unshift(tag);

    res.locals.$$VIEW.title = sequence.join(` ${delimiter} `);
  }
  if (typeof next === 'function') return next();
};


// /**
//  * normalize body parser result
//  */
// const postNormalizer = async (req, res, next) => {
//   if (req.method === 'GET' || !req.body.post) return next();
//   const { post } = req.body;
//
//   // canonicalize                                                                                                       // todo: move to error handler
//   const checkAndResolveConflict = (str) => PostsModel
//     .count({ canonical: { $regex: new RegExp(`^${str}(?:-[0-9]+)?$`) } })
//     .then(counts => {
//       if (counts > 0) return `${str}-${counts + 1}`;
//       return str;
//     });
//
//   // normalize                                                                                                          // todo: only normalize for POST, PATCH (different logic)
//   const normalizedPost = {
//     ...post,
//     // featured: _U_.string.inspectFileURL(post.featured, res.locals.$$SITE.sets.imageTypes),                           // tofix: `inspectFileURL` have been deprecated
//     category: _U_.string.toKebabCase(post.category) || null,
//     content: _U_.string.toEscapedChars(post.content),
//     title: _U_.string.toEscapedChars(post.title),
//     tags: _U_.string.toKebabCase(post.tags) || null,
//   };
//   if (post.state) {
//     normalizedPost.state.forEach(state => {
//       normalizedPost[`state.${state}`] = true;
//     });
//   }
//   if (req.method === 'POST') {
//     normalizedPost.canonical = await checkAndResolveConflict(_U_.string.toKebabCase(post.title));
//   }
//
//   // overwrite
//   req.body.post = normalizedPost;
//
//   return next();
// };


// exports
module.exports = {
  caseInsensitiveQueryProxy,
  modifyHTMLTitleTag,
  // postNormalizer,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/index.js":
/*!*************************************************!*\
  !*** ./src/server/controllers/modules/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const auth = __webpack_require__(/*! ./auth */ "./src/server/controllers/modules/auth.js");
const header = __webpack_require__(/*! ./header */ "./src/server/controllers/modules/header.js");
const helper = __webpack_require__(/*! ./helper */ "./src/server/controllers/modules/helper.js");
const { paginatedQuery } = __webpack_require__(/*! ./query/packet */ "./src/server/controllers/modules/query/packet.js");
const { handleStreamUpload } = __webpack_require__(/*! ./upload/packet */ "./src/server/controllers/modules/upload/packet.js");


// exports
module.exports = { _M_: { ...auth, ...helper, ...header, paginatedQuery, handleStreamUpload } };


/***/ }),

/***/ "./src/server/controllers/modules/query/helpers.js":
/*!*********************************************************!*\
  !*** ./src/server/controllers/modules/query/helpers.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _U_ } = __webpack_require__(/*! ../../utilities/ */ "./src/server/controllers/utilities/index.js");


// helpers
/**
 * compose a hashed object containing Mongo query expressions for pagination
 * @param {object} query                    - express.js query object
 * @param {number} [num]                    - preset numbers of document per page
 * @return {object}                         - a collection of Mongo expressions contains paginating variables
 */
const paginatedMetaExpression = (query, num = 10) => {
  const $$page = Math.trunc(query.page > 1 ? query.page : 1);
  const $$num = Math.trunc(query.num > 0 ? query.num : num);
  const $$end = { $ceil: { $divide: ['$count', $$num] } };
  const $$now = { $cond: { if: { $lt: [$$page, $$end] }, then: { $literal: $$page }, else: $$end } };
  return { page: $$page, num: $$num, end: $$end, now: $$now };
};


/**
 * compose Mongo query expression based on a time range from an array
 * @param {array} start                     - an array formatted as [YYYY, MM, DD]
 * @param {array} end                       - an array formatted as [YYYY, MM, DD]
 * @return {object}                         - part-of expression in $match stage
 */
const queryDateExpression = (start, end) => {
  if (!start || !end || start.length !== 3 || end.length !== 3) return null;
  const [A, Z] = [(start < end) ? start : end, (start < end) ? end : start];
  const [G, L] = [{ Y: A[0], M: A[1], D: A[2] }, { Y: Z[0], M: Z[1], D: Z[2] }];
  G.D = G.Y ? G.M ? G.D ? G.D : (G.D += 1) : (G.D += 1) : L.M && L.D ? L.D : (G.D += 1);
  G.M = G.Y ? G.M ? (G.M -= 1) : G.M : L.M ? L.M - 1 : G.M;
  G.Y = G.Y ? G.Y : L.Y;
  L.Y = L.M ? L.Y : (L.Y += 1);
  L.M = L.M && L.D ? (L.M -= 1) : L.M;
  L.D += 1;
  return { $gte: new Date(Date.UTC(G.Y, G.M, G.D)), $lt: new Date(Date.UTC(L.Y, L.M, L.D)) };
};


/**
 * parse date query into an date array
 * @param {string} str                      - query string
 * @return {array}                          - an array shaped as [[YYYY, MM, DD], [YYYY, MM, DD]]
 */
const parseQueryDate = (str) => {
  if (!str || !_U_.string.checkToStringTag(str, 'String')) return [];
  //
  const group = '((?:\\d{4}(?:(?:0[1-9]|1[0-2])(?:0[1-9]|[1-2][0-9]|3[0-1])?)?)?)';
  const query = new RegExp(`^(?!-?\\/?$)${group}(?:-|\\/?$)${group}\\/?$`);
  const range = new RegExp('(\\d{4})(\\d{2})(\\d{2})');
  return (query.exec(str) || []).slice(1, 3)
    .map(date => range.exec(date.padEnd(8, '0')).slice(1, 4)
      .map(value => Number(value)));
};


/**
 * parse sorting query into fieldName-direction entries
 * @param {string} str                      - query string
 * @param {string} [order]                  - contains information about sorting direction
 * @param {number} [preset]                 - default sorting direction (as descending direction)
 * @return {array}                          - an array shaped as [[fieldName, direction], ...]
 */
const parseQuerySort = (str, order = '', preset = -1) => {
  if (!str || !_U_.string.checkToStringTag(str, 'String')) return [];
  //
  const entries = [];
  const flag = order.split(':')[1];
  const weight = flag === 'a' ? 1 : flag === 'd' ? -1 : 0;
  const item = str && str.split(',');
  for (let i = item.length - 1; i > -1; i -= 1) {
    const [field, directionFlag] = item[i].split(':');
    const fieldWeight = (Math.trunc(directionFlag) && (directionFlag > 0 ? 1 : -1))
        || (directionFlag === 'a' && 1)
        || (directionFlag === 'd' && -1)
        || (preset > 0 ? 1 : -1);
    entries.push([field.trim(), weight || fieldWeight]);
  }
  return entries.reverse();
};


// exports
module.exports = {
  paginatedMetaExpression,
  queryDateExpression,
  parseQueryDate,
  parseQuerySort,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/query/packet.js":
/*!********************************************************!*\
  !*** ./src/server/controllers/modules/query/packet.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _U_ } = __webpack_require__(/*! ../../utilities/ */ "./src/server/controllers/utilities/index.js");
const { getAggregationQuery } = __webpack_require__(/*! ./pipes */ "./src/server/controllers/modules/query/pipes.js");
const modelIndex = __webpack_require__(/*! ../../../models/ */ "./src/server/models/index.js");


// middleware
/**
 * (factory) populate paginated query result via Mongo aggregation
 * @param {string} collection               - MongoDB collection name
 * @param {number} [num]                    - preset numbers of document per page
 * @param {object} [sort]                   - preset sorting configurations
 * @return {function}
 */
const paginatedQuery = (collection, { num, sort } = {}) => function queryController(req, res, next) {
  const Model = modelIndex[`${_U_.string.toCapitalized(collection)}Model`];
  return Model
    .aggregate(getAggregationQuery(collection, req.params, req.query, num || res.locals.$$SITE.num, sort))
    .then(docs => docs[0])
    .then(result => {
      if (result) req.session.cache = result;
      if (result && result.list) req.session.cache.list = result.list.map(doc => Model.hydrate(doc));
      return next();
    })
    .catch(next);
};


// exports
module.exports = {
  paginatedQuery,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    getAggregationQuery,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/query/pipes.js":
/*!*******************************************************!*\
  !*** ./src/server/controllers/modules/query/pipes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { paginatedMetaExpression, queryDateExpression, parseQueryDate, parseQuerySort } = __webpack_require__(/*! ./helpers */ "./src/server/controllers/modules/query/helpers.js");


// aggregation pipes
/**
 * pull-pipeline stage 1: matching rules
 * @param {string} collection               - MongoDB collection name
 * @param {object} params                   - express.js param object
 * @param {object} query                    - express.js query object
 * @return {{$match}}
 */
const pullPipe_1_matching = (collection, params, query) => {
  const $match = params.search ? { $text: { $search: params.search } } : {};
  const _$$date = query.date ? queryDateExpression(...parseQueryDate(query.date)) : null;                               // tofix: query time zone problem
  if (_$$date) $match['time._created'] = _$$date;
  if (['posts', 'media', 'page'].includes(collection)) {
    $match['time._recycled'] = (params.collection && query.access === 'bin') ? { $ne: null } : { $eq: null };
    if (!params.collection) $match['state.published'] = true;
    if (!params.collection) $match['state.hidden'] = false;
  }
  return { $match };
};


/**
 * pull-pipeline stage 2: fields masking
 * @param {object} params                   - express.js param object
 * @return {{$project}}
 */
const pullPipe_2_masking = (params) => {
  const $project = {};
  const mask = ['content'];
  if (params.collection) mask.push('featured');
  for (let i = mask.length - 1; i > -1; i -= 1) $project[mask[i]] = 0;
  return { $project };
};


/**
 * pull-pipeline stage 3: fields sorting
 * @param {object} query                    - express.js query object
 * @param {object} [sort]                   - preset sorting configurations
 * @return {{$project}}
 */
const pullPipe_3_sorting = (query, sort = {}) => {
  const $sort = { 'state.pinned': -1, 'time._updated': -1, ...sort };
  const sortMap = new Map();
  Object.keys(query)
    .filter(key => ['sort', 'sort:a', 'sort:d'].includes(key))
    .forEach(rule => parseQuerySort(query[rule], rule).forEach(pair => sortMap.set(...pair)));
  //
  if (sortMap.has('pin'))       $sort['state.pinned']     = sortMap.get('pin');
  if (sortMap.has('time'))      $sort['time._updated']    = sortMap.get('time');
  if (sortMap.has('update'))    $sort['time._updated']    = sortMap.get('update');
  if (sortMap.has('post'))      $sort['time._created']    = sortMap.get('post');
  if (sortMap.has('author'))    $sort['author.nickname']  = sortMap.get('author');
  if (sortMap.has('title'))     $sort.title               = sortMap.get('title');
  if (sortMap.has('category'))  $sort.category            = sortMap.get('category');
  if (sortMap.has('tags'))      $sort.tags                = sortMap.get('tags');
  if (sortMap.has('revise'))    $sort._revised            = sortMap.get('revise');
  return { $sort };
};


/**
 * pull-pipeline stage 4: grouping with document counting
 * @return {{$group}}
 */
const pullPipe_4_grouping = () => {
  const $group = { _id: null, count: { $sum: 1 }, list: { $push: '$$ROOT' } };
  return { $group };
};


/**
 * pull-pipeline stage 5: paginating projection
 * @param {object} query                    - express.js query object
 * @param {number} num                      - preset numbers of document per page
 * @param {object} sort                     - preset sorting configurations
 * @return {{$project}}
 */
const pullPipe_5_paginating = (query, num, sort) => {
  const $$meta = paginatedMetaExpression(query, num);
  const $project = {
    _id: 0,
    list: { $slice: ['$list', { $multiply: [{ $add: [$$meta.now, -1] }, $$meta.num] }, $$meta.num] },
    meta: {
      count: '$count',
      num: { $literal: $$meta.num },
      now: $$meta.now,
      end: $$meta.end,
      sort: { $literal: pullPipe_3_sorting(query, sort).$sort },
      period: { $literal: queryDateExpression(...parseQueryDate(query.date)) },
    },
  };
  return { $project };
};


// const pushPipe_1_modifying = (body) => {
//   const _$$filter = { $filter: { input: '$list', as: 'doc', cond: {
//         $and: [{ $in: ['$$doc._id', [ObjectId('5ab33bec53da62203f81676d')] /** body.list.map(i => ObjectId(i)) **/] } /** ,additional matcher **/]}
//     }};
//   const _$$map = { $map: { input: _$$filter, as: 'doc', in: { $mergeObjects: ['$$doc', body] }}};
//   const $project = { list: _$$map };
//   return { $project };
// };
//
//
// const pushPipe_2_splitting = () => {
//   const $unwind = '$list';
//   return { $unwind };
// };
//
//
// const pushPipe_3_destructuring = () => {
//   const $replaceRoot = { newRoot: '$list' };
//   return { $replaceRoot };
// };
//
//
// const pushPipe_4_overwriting = (collection) => {
//   const $out = collection;                                                                                              // todo: note: <CURRENT MONGODB IS NOT SUPPORTED> current (v3.6): overwrite the whole collection (x)
//   return { $out };
// };


// query-builder
/**
 * combined all pipeline stages into an Mongo aggregation query
 * @param {string} collection               - MongoDB collection name
 * @param {object} params                   - express.js param object
 * @param {object} query                    - express.js query object
 * @param {number} num                      - preset numbers of document per page
 * @param {object} sort                     - preset sorting configurations
 * @return {array}                          - Mongo aggregation query
 */
const getAggregationQuery = (collection, params, query, num, sort/** , update **/) => {
  const pullDocuments = [
    pullPipe_1_matching(collection, params, query),
    pullPipe_2_masking(params),
    pullPipe_3_sorting(query, sort),
    pullPipe_4_grouping(),
    pullPipe_5_paginating(query, num, sort),
  ];

  // const pushDocuments = [
  //   ...pullDocuments,
  //   pushPipe_1_modifying(update),
  //   pushPipe_2_splitting(),
  //   pushPipe_3_destructuring(),
  //   pushPipe_4_overwriting(collection)
  // ];

  return pullDocuments;
  // return update ? pushDocuments : pullDocuments;
};


// exports
module.exports = {
  getAggregationQuery,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    pullPipe_1_matching,
    pullPipe_2_masking,
    pullPipe_3_sorting,
    pullPipe_4_grouping,
    pullPipe_5_paginating,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/upload/handlers.js":
/*!***********************************************************!*\
  !*** ./src/server/controllers/modules/upload/handlers.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const fs = __webpack_require__(/*! fs */ "fs");


// modules
const { _U_ } = __webpack_require__(/*! ../../utilities/ */ "./src/server/controllers/utilities/index.js");
const { getSavingPath, isUploadable, fetchRawDoc, fetchMessage, upload } = __webpack_require__(/*! ./helpers */ "./src/server/controllers/modules/upload/helpers.js");


// handlers
/**
 * handle `file` event emitted by busboy
 * @param slip                              - document population pool
 * @param {object} configs                  - upload configurations
 */
const handleOnFile = function handleOnFile(slip, configs) {
  return (fieldName, stream, fileName, encoding, MIME) => {
    const task = { fieldName, stream, fileName, encoding, MIME, filePath: getSavingPath(configs.pathBase, fileName) };
    const busboy = this;
    stream.on('error', err => busboy.emit('error', err));
    stream.on('end', () => {
      // update slip
      _U_.object.mergeDeep(slip.raw, fetchRawDoc(task, configs), { mutate: true });
      slip.mes.add(fetchMessage(task, configs));

      // cleanup debris
      if (stream.truncated) fs.unlink(task.filePath, err => (err ? stream.emit('error', err) : undefined));
    });

    // stream
    return (isUploadable(task, configs)) ? upload(task) : stream.resume();                                              // note: both function will emit 'end' event at the end
  };
};


/**
 * handle `field` event emitted by busboy
 * @param slip                              - document population pool
 * @param {object} configs                  - upload configurations
 */
const handleOnField = function handleOnField(slip, configs) {
  return (fieldName, value, truncatedName, truncatedValue, encoding, MIME) => {
    if (value) _U_.object.assignDeep(slip.raw, fieldName, _U_.string.toEscapedChars(value), { mutate: true });
  };
};


/**
 * (middleware) handle `finish` event emitted by busboy
 * @param slip                              - document population pool
 */
const handleOnFinish = (slip) => function handleOnBusboySlip(req, res, next) {
  req.body.busboySlip = {
    raw: Object.values(slip.raw).filter(obj => obj.isSkipped !== true),
    mes: [...slip.mes],
  };
  return next();
};


// exports
module.exports = {
  handleOnFile,
  handleOnField,
  handleOnFinish,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/upload/helpers.js":
/*!**********************************************************!*\
  !*** ./src/server/controllers/modules/upload/helpers.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");


// modules
const { _U_ } = __webpack_require__(/*! ../../utilities/ */ "./src/server/controllers/utilities/index.js");


// helpers
/**
 * compose the upload path and saving file name                                                                         // note: can only be called once in a stream
 * @param {object} pathBase                 - default path
 * @param {object} fileName                 - original filename
 * @return {string}                         - file saving path
 */
const getSavingPath = (pathBase, fileName) => {
  const fireTime = new Date(Date.now());
  const filePath = fireTime.getUTCFullYear() + `0${fireTime.getUTCMonth() + 1}`.slice(-2);
  const uniqueName = fireTime.getTime() + path.extname(fileName);
  return path.join(pathBase, filePath, uniqueName);
};


/**
 * check if the file is uploadable
 * @param {object} task                     - busboy emitted arguments
 * @param {object} configs                  - upload configurations
 * @return {boolean}                        - uploadable(true) / in-uploadable(false)
 */
const isUploadable = (task, configs) => {
  return !(!task.fileName || !configs.MIME.includes(task.MIME) || task.stream.truncated);
};


/**
 * parse to give a raw document
 * @param {object} task                     - busboy emitted arguments
 * @param {object} configs                  - upload configurations
 * @return {object}                         - parsed document to be merged
 */
const fetchRawDoc = (task, configs) => {
  if (isUploadable(task, configs)) {
    const pathParser = path.parse(task.filePath);
    const doc = { ext: pathParser.ext.slice(1), path: task.filePath, name: pathParser.base };
    return _U_.object.assignDeep({}, task.fieldName, doc);
  }
  return _U_.object.assignDeep({}, _U_.string.parseObjPath(task.fieldName)[0], { isSkipped: true });
};


/**
 * parse to stack messages
 * @param {object} task                     - busboy emitted arguments
 * @param {object} configs                  - received configurations
 * @return {string}                         - message to be stacked
 */
const fetchMessage = (task, configs) => {
  const { stream, fileName, MIME } = task;
  if (!fileName) return 'No files were uploaded.';                                                                      // tofix: centralized message; only display when upload = 0
  if (!configs.MIME.includes(MIME)) return `"${fileName}" is in a unsupported file type.`;
  if (stream.truncated) return `"${fileName}" exceed the file size limit (${configs.fileSize / 1000000}MB).`;
  return '';
};


/**
 * pipe the busboy readable stream with fs writable stream to upload the file
 * @param {object} task                     - busboy emitted arguments
 */
const upload = (task) => {
  const { stream, filePath } = task;
  const fileStream = () => fs.createWriteStream(filePath).on('error', err => {
    if (err && err.code !== 'ENOENT') stream.emit('error', new _U_.error.ServerError(err));
    else if (err) stream.emit('mkdir', path.dirname(filePath));
  });
  stream.on('mkdir', directory => fs.mkdir(directory, err => {
    if (err) stream.emit('error', new _U_.error.ServerError(92001, `${directory}\n${err.toString()}`));
    else stream.pipe(fileStream());
  }));
  stream.pipe(fileStream());
};


// exports
module.exports = {
  getSavingPath,
  isUploadable,
  fetchRawDoc,
  fetchMessage,
  upload,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/modules/upload/packet.js":
/*!*********************************************************!*\
  !*** ./src/server/controllers/modules/upload/packet.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Busboy = __webpack_require__(/*! busboy */ "busboy");


// helpers
const { handleOnFile, handleOnField, handleOnFinish } = __webpack_require__(/*! ./handlers */ "./src/server/controllers/modules/upload/handlers.js");


// middleware
/**
 * (factory) handle/parse multipart upload by stream
 * @param setting
 */
const handleStreamUpload = (setting = {}) => function uploadController(req, res, next) {
  const slip = { raw: {}, mes: new Set() };
  const configs = {
    ...setting,
    pathBase: req.app.get('upload'),
    fileSize: setting.fileSize ? setting.fileSize : (25 * 1000000),                                                     // tofix: use default value (from env)
    MIME: setting.MIME ? setting.MIME : ['image/png', 'image/gif', 'image/jpeg', 'image/svg+xml', 'image/x-icon'],      // tofix: use default value (from env)
  };
  const busboy = new Busboy({ headers: req.headers, limits: configs });
  req.pipe(busboy
    .on('file', handleOnFile.bind(busboy)(slip, configs))
    .on('field', handleOnField.bind(busboy)(slip, configs))
    .on('finish', () => handleOnFinish(slip)(req, res, next))
    .on('error', err => {
      if (err) {
        busboy.removeAllListeners();
        return next(err); // note: only receive an unexpected server error
      }
    }));
};


// exports
module.exports = {
  handleStreamUpload,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/routers/auth.js":
/*!************************************************!*\
  !*** ./src/server/controllers/routers/auth.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const passport = __webpack_require__(/*! passport */ "passport");
const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");
const { UsersModel } = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");
const { _U_: { error: { ClientException } } } = __webpack_require__(/*! ../utilities/ */ "./src/server/controllers/utilities/index.js");


// controllers
const auth = {};

auth.signup = {
  GET: function auth_signup_GET(req, res, next) {
    if (req.isAuthenticated()) return res.redirect('/home');
    return next();
  },
  POST: [_M_.isValidPasswordSyntax, async function auth_signup_POST(req, res) {
    const newUser = await UsersModel.register(new UsersModel(req.body), req.body.password.new);
    req.logIn(newUser, err => {
      if (err) throw err;
      req.flash('info', `Welcome new user: ${req.body.username}`);
      return res.redirect('/home');
    });
  }],
};


auth.signin = {
  GET: function auth_signin_GET(req, res, next) {
    if (req.isAuthenticated()) return res.redirect('/home');
    if (res.locals.$$VIEW.flash.action.includes('retry')) req.flash('action', 'retry');                                 // note: // preserve `returnTo` if client not visit any other pages
    return next();
  },
  POST: function auth_signin_POST(req, res, next) {
    if (req.isAuthenticated()) return res.redirect('/home');
    return passport.authenticate('local', (authErr, authUser) => {
      if (authErr) return next(authErr);
      if (!authUser) return next(new ClientException(20002));
      return req.logIn(authUser, loginErr => {
        if (loginErr) return next(loginErr);
        authUser.updateLastTimeLog('signIn');
        req.session.cookie.expires = new Date(req.body.isPersisted ? (14 * 24 * 3600000) + Date.now() : Date.now());
        req.session.user = { _id: authUser._id, picture: authUser.picture, nickname: authUser.nickname };
        req.flash('info', `Welcome back ${authUser.nickname}!`);
        return res.redirect(req.session.returnTo || '/home');
      });
    })(req, res, next);
  },
};


auth.signout = {
  GET: function auth_signout_GET(req, res) {
    if (req.isAuthenticated()) {
      req.logout();
      req.flash('info', 'See you next time!');
      delete req.session.user;
    }
    return res.redirect('back');
  },
};


// exports
module.exports = { auth };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/routers/blog.js":
/*!************************************************!*\
  !*** ./src/server/controllers/routers/blog.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");
const { _U_ } = __webpack_require__(/*! ../utilities/ */ "./src/server/controllers/utilities/index.js");
const { PostsModel } = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");


// controllers
const blog = {};

blog.edit = {
  alias: async function blog_edit_alias(req, res) {
    const post = await PostsModel.findOne({ canonical: req.params.canonical });
    if (!post) throw new _U_.error.HttpException(404);
    req.session.cache = { post };
    return res.redirect(`/blog/${req.session.cache.post._id}/edit`);
  },
  GET: async function blog_edit_GET(req, res, next) {
    if (req.url.match(/^\/(edit|new)\/?$/)) req.session.cache = { post: new PostsModel() };
    else if (!req.session.cache
        || !req.session.cache.post
        || !req.url.includes(req.session.cache.post._id)) {
      req.session.cache = { post: await PostsModel.findById(_U_.string.parseMongoObjectId(req.url)) };
    }
    return next();
  },
};


blog.post = {
  alias: async function blog_post_alias(req, res, next) {
    if (!req.session.cache
        || !req.session.cache.post
        || req.session.cache.post.canonical !== req.params.canonical) {
      req.session.cache = { post: await PostsModel.findOne({
        canonical: req.params.canonical, 'time._recycled': { $eq: null },
      }) };
    }
    return next();
  },
  GET: async function blog_post_GET(req, res) {
    const post = await PostsModel.findOne({ _id: req.params[0], 'time._recycled': { $eq: null } });
    if (!post) throw new _U_.error.HttpException(404);
    req.session.cache = { post };
    return res.redirect(`/blog/${req.session.cache.post.canonical}`);
  },
  PUT: async function blog_post_PUT(req, res) {
    const post = await PostsModel.update(
      { _id: _U_.string.parseMongoObjectId(req.url) },
      { $set: req.body.post },
      { new: true },
    );
    req.session.cache = { post };
    req.flash('info', 'post have been successfully updated!');
    return res.redirect(`/blog/${post.canonical}`);
  },
  DELETE: async function blog_post_DELETE(req, res) {
    await PostsModel.remove({ _id: _U_.string.parseMongoObjectId(req.url) });
    req.flash('info', 'post have been successfully deleted!');
    return res.redirect('/blog/');
  },
};


blog.list = {
  GET: function blog_list_GET(req, res, next) {
    return _M_.paginatedQuery('posts')(req, res, next);
  },
  POST: async function blog_list_POST(req, res) {
    await PostsModel.create({ author: req.session.user, ...req.body.post });
    req.flash('info', 'post have been successfully posted!');
    return res.redirect('/blog/');
  },
};


// exports
module.exports = { blog };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/routers/home.js":
/*!************************************************!*\
  !*** ./src/server/controllers/routers/home.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");
const { UsersModel } = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");


// controllers
const home = {};

home.profile = {
  GET: function home_profile_GET(req, res, next) {
    res.locals.$$VIEW.user = req.user.toObject();
    return next();
  },
  PATCH: async function home_profile_PATCH(req, res) {
    await UsersModel.update({ _id: req.user._id }, { $set: {
      info: req.body.profile.info, nickname: req.body.profile.nickname, _$nickname: req.user.nickname,
    } });
    req.flash('info', 'Your profile have been successfully updated!');
    return res.redirect('/home/profile');
  },
};


home.security = {
  GET: function home_security_GET(req, res, next) {
    return next();
  },
  PATCH: [_M_.isValidPasswordSyntax, async function home_security_PATCH(req, res) {
    await req.user.changePassword(req.body.password.old, req.body.password.new);
    req.flash('info', 'Password have been successfully changed.');
    return res.redirect('/home/profile');
  }],
};


// exports
module.exports = { home };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/routers/index.js":
/*!*************************************************!*\
  !*** ./src/server/controllers/routers/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { auth } = __webpack_require__(/*! ./auth */ "./src/server/controllers/routers/auth.js");
const { blog } = __webpack_require__(/*! ./blog */ "./src/server/controllers/routers/blog.js");
const { home } = __webpack_require__(/*! ./home */ "./src/server/controllers/routers/home.js");
const { init } = __webpack_require__(/*! ./init */ "./src/server/controllers/routers/init.js");
const { page } = __webpack_require__(/*! ./page */ "./src/server/controllers/routers/page.js");
const { site } = __webpack_require__(/*! ./site */ "./src/server/controllers/routers/site.js");


// exports
module.exports = { auth, blog, home, init, page, site };


/***/ }),

/***/ "./src/server/controllers/routers/init.js":
/*!************************************************!*\
  !*** ./src/server/controllers/routers/init.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");
const { PostsModel, UsersModel, ConfigsModel } = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");


// seed
const seed = {
  user: {
    role: 'admin',
    username: 'admin',
    picture: '/static/default/admin_picture.png',
  },
  post: {
    title: 'Hello World!',
    content: 'Welcome to OpenBox CMS, this is your first post!',
  },
};


// controllers
const init = {
  GET: function init_GET(req, res, next) {
    if (req.app.get('APP_CONFIG').initialized) return res.redirect('/');
    return next();
  },
  POST: [_M_.isValidPasswordSyntax, async function init_POST(req, res, next) {
    if (req.app.get('APP_CONFIG').initialized) return res.redirect('/');
    const adminRaw = { ...req.body, ...seed.user, nickname: req.body.nickname || 'admin' };
    const admin = await UsersModel.register(new UsersModel(adminRaw), req.body.password.new);
    const config = ConfigsModel.updateConfig(req.app, { initialized: true });
    const post = PostsModel.create({ author: admin, ...seed.post });
    return req.logIn(admin, async (err) => {
      if (err) return next(err);
      admin.updateLastTimeLog('signIn');
      req.session.user = { _id: admin._id, picture: admin.picture, nickname: admin.nickname };
      req.flash('info', `Welcome ${admin.nickname || 'admin'}`);
      await Promise.all([post, config]);
      return res.redirect('/blog/hello-world');
    });
  }],
};


// exports
module.exports = { init };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/routers/page.js":
/*!************************************************!*\
  !*** ./src/server/controllers/routers/page.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");


// controllers
const page = {};

page.search = {
  GET: function page_search_GET(req, res, next) {
    return _M_.paginatedQuery('posts')(req, res, next);
  },
};


page.edit = {
  GET: function page_edit_GET(req, res, next) {
    return next();
  },
};


page.show = {
  GET: function page_show_GET(req, res, next) {
    return next();
  },
};


page.root = {
  GET: function page_root_GET(req, res, next) {
    return next();
  },
};


// exports
module.exports = { page };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/routers/site.js":
/*!************************************************!*\
  !*** ./src/server/controllers/routers/site.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_ } = __webpack_require__(/*! ../modules/ */ "./src/server/controllers/modules/index.js");
const { _U_ } = __webpack_require__(/*! ../utilities/ */ "./src/server/controllers/utilities/index.js");
const ModelIndex = __webpack_require__(/*! ../../models/ */ "./src/server/models/index.js");


// controllers
const site = {};


site.configs = {
  GET: function site_configs_GET(req, res, next) {
    return next();
  },
  PATCH: async function site_configs_PATCH(req, res) {
    await ModelIndex.ConfigsModel.updateConfig(req.app, req.body.configs);                                                      // tofix: pickup updated variables to avoid injections
    return res.redirect('back');
  },
};


site.upload = {                                                                                                         // todo: to be integrated in profile and media manager
  GET: function site_upload_GET(req, res, next) {
    return next();
  },
  POST: [_M_.handleStreamUpload({ fileSize: 25 * 1048576 }), async function site_upload_POST(req, res) {
    const { raw = [], mes = [] } = req.body.busboySlip;
    if (mes.length) mes.map(hint => req.flash('error', hint));
    if (raw.length) {
      for (let i = raw.length - 1, doc = raw[i]; i > -1; doc = raw[i -= 1]) doc.author = req.session.user;
      const docs = await ModelIndex.MediaModel.create(raw);
      req.flash('info', `${docs.length} file(s) successfully uploaded!`);
    }
    return res.redirect('back');
  }],
};


site.stack = {
  GET: async function site_stack_GET(req, res, next) {
    const collection = req.params.collection.toLowerCase();
    if (!['posts', 'media'].includes(collection)) throw new _U_.error.HttpException(404);
    //
    return _U_.express.wrapMiddleware([
      _M_.modifyHTMLTitleTag(collection),
      _M_.paginatedQuery(collection, { num: 10 }),
    ])(req, res, next);
  },
  PATCH: async function site_stack_PATCH(req, res) {
    const collection = req.params.collection.toLowerCase();
    if (!['posts', 'media'].includes(collection)) throw new _U_.error.HttpException(404);
    //
    const { action, target = [] } = req.body;
    if (action && target.length) {
      const model = ModelIndex[`${_U_.string.toCapitalized(collection)}Model`];
      await model.update({ _id: { $in: target } }, { $set: { [`state.${action}`]: true } }, { multi: true });
    }
    return res.redirect('back');
  },
};


site.root = {
  GET: function site_main_GET(req, res, next) {
    return next();
  },
};


// exports
module.exports = { site };

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/utilities/error-code/index.js":
/*!**************************************************************!*\
  !*** ./src/server/controllers/utilities/error-code/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-shadow, no-template-curly-in-string */
const { checkToStringTag } = __webpack_require__(/*! ../string */ "./src/server/controllers/utilities/string.js");


class ErrorCodeDictionary {
  constructor(dictionary) {
    this.dictionary = new Map(Object.entries(dictionary).map(pair => [+pair[0], pair[1]]));
  }

  lookup(entry, literals) {
    if (!this.dictionary.has(entry)) return null;
    if (!['Object', 'String'].includes(checkToStringTag(literals))) return this.dictionary.get(entry);

    // replacing with template literals
    return this.dictionary.get(entry).replace(/\${([^}]*)}/g, (match, key) => {
      const replacement = checkToStringTag(literals, 'Object')
        ? literals[key] || literals[key] === 0 ? literals[key] : match
        : literals;
      return `${replacement}`.trim();
    });
  }
}


// dictionary collection
const collection = new Map();

collection.set('ServerError_en', new ErrorCodeDictionary({
  90001: 'Failed to load website configs, please contact the admin.',
  92001: '[MultiPartUpload] Cannot create the folder (fs.mkdir, missing parent folder?): ${dirPath}',
  92002: '[MultiPartUpload] Failed to clean up the truncated file...\n${errString}',
}));

collection.set('TemplateException_en', new ErrorCodeDictionary({
  91001: 'Failed to compile template function: ${filePath}\n${err}',
  91002: 'Failed to render template function: ${filePath}\n${err}',
  91003: 'Failed to asynchronously lookup file (fs.readFile): ${filePath}',
  91004: 'Failed to synchronously lookup file (fs.readFileSync): ${filePath}',
}));

collection.set('ClientException_en', new ErrorCodeDictionary({
  10001: 'Please fill all required fields.',
  10002: 'Two new password does not the same.',
  10003: 'Password cannot be set to the same as the current.',
  20000: 'Please sign in first!',
  20001: 'Invalid authorization...',
  20002: 'Wrong email/username or password!',
}));

collection.set('HttpException_en', new ErrorCodeDictionary({
  400: 'HTTP 400 - Bad Request.',
  401: 'HTTP 401 - Unauthorized.',
  403: 'HTTP 403 - Forbidden.',
  404: 'HTTP 404 - Not found.',
  500: 'HTTP 500 - Internal Server Error.',
}));


// exports
module.exports = new Proxy(collection, {
  get: (collection, name) => {
    const book = `${name}_${process.env.LANG || 'en'}`;
    if (collection.has(book)) return (entry, literals) => collection.get(book).lookup(entry, literals) || entry;
    return (entry) => entry;
  },
});


/***/ }),

/***/ "./src/server/controllers/utilities/error.js":
/*!***************************************************!*\
  !*** ./src/server/controllers/utilities/error.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { checkToStringTag } = __webpack_require__(/*! ./string */ "./src/server/controllers/utilities/string.js");
const errorCodeProxyAgent = __webpack_require__(/*! ./error-code/ */ "./src/server/controllers/utilities/error-code/index.js");


// main
class ExtendableError extends Error {
  constructor(entry, literals) {
    if (Reflect.getPrototypeOf(new.target) === TransferableError) {                                                     // note: lock-in this parental class can be only extended by a special child class
      super();
      this.name = this.constructor.name;
      this.message = String(errorCodeProxyAgent[this.name](entry, literals));
      if (checkToStringTag(entry, 'Number')) this.code = entry;
      if (!Error.captureStackTrace) this.stack = (new Error(this.message)).stack;                                       // note: V8 JS-engine only
      else Error.captureStackTrace(this, this.constructor);                                                             // note: non-V8 browser only
    }
  }
}


class TransferableError extends ExtendableError {
  constructor(entry, literals) {
    if (new.target !== TransferableError) {
      if (entry instanceof ExtendableError) return entry;
      if (entry instanceof Error) {
        super(entry.message);
        this.code = entry.code;
        this.from = entry.name;
        this.stack = `${this.name} (transferred):${new RegExp(/\s+at.+[^\n]/).exec(this.stack)[0]}\n${entry.stack}`;
      } else {
        super(entry, literals);
      }
    }
  }
}


// extensions
class ServerError extends TransferableError {}                                                                          // note: this type is not intended to handle by the middleware
class TemplateException extends TransferableError {}
class ClientException extends TransferableError {}
class HttpException extends TransferableError {}


// exports
module.exports = {
  ServerError,
  ClientException,
  TemplateException,
  HttpException,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ExtendableError,
    TransferableError,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/utilities/express.js":
/*!*****************************************************!*\
  !*** ./src/server/controllers/utilities/express.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { checkToStringTag } = __webpack_require__(/*! ./string */ "./src/server/controllers/utilities/string.js");
const { Router } = __webpack_require__(/*! express */ "express");


/**
 * (decorator) handle asyncfunction for error bubbling
 * @param {array|function} target           - fn to be wrapped
 * @return {array|function}                 - wrapped middleware
 */
const wrapAsync = (target) => {
  const unnamedWrapper = (fn) => (...arg) => fn.apply(this, arg).catch(arg[arg.length - 1]);
  const namedWrapper = (fn) => Object.defineProperty(unnamedWrapper(fn), 'name', { value: `wrappedAsync ${fn.name}` });
  const evaluator = (fn) => (checkToStringTag(fn, 'AsyncFunction') ? namedWrapper(fn) : fn);
  const type = checkToStringTag(target);
  if (type === 'Array') return target.map(fn => evaluator(fn));
  return evaluator(target);
};


/**
 * (factory) insert additional middleware into the chain
 * @param {array|function} target           - fn to be wrapped
 * @return {function}                       - repacked middleware
 */
const wrapMiddleware = (queue) => {
  const router = new Router({ mergeParams: true });
  const type = checkToStringTag(queue);
  switch (type) {
    case 'Array':
    case 'Function':
    case 'AsyncFunction':
      return router.use(wrapAsync(queue));
    case 'Map':
      queue.forEach((condition, middleware) => {
        if (condition) router.use(wrapAsync(middleware));
      });
      return router;
    default: {
      throw new TypeError(`Argument is neither an Array, Map, nor (Async)Function but ${type}.`);
    }
  }
};


// exports
module.exports = {
  wrapAsync,
  wrapMiddleware,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/utilities/index.js":
/*!***************************************************!*\
  !*** ./src/server/controllers/utilities/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const utilities = {
  _U_: {
    express: __webpack_require__(/*! ./express */ "./src/server/controllers/utilities/express.js"),
    object: __webpack_require__(/*! ./object */ "./src/server/controllers/utilities/object.js"),
    string: __webpack_require__(/*! ./string */ "./src/server/controllers/utilities/string.js"),
    error: __webpack_require__(/*! ./error */ "./src/server/controllers/utilities/error.js"),
  },
};


// exports
module.exports = utilities;


/***/ }),

/***/ "./src/server/controllers/utilities/object.js":
/*!****************************************************!*\
  !*** ./src/server/controllers/utilities/object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-restricted-syntax */
const { checkToStringTag, parseObjPath } = __webpack_require__(/*! ./string */ "./src/server/controllers/utilities/string.js");


/**
 * check if object has the property
 * @param {object} obj                      - object to be evaluate
 * @param {string} prop                     - name of the property
 * @return {boolean}                        - evaluation result
 */
const hasOwnKey = (obj, prop) => {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};


/**
 * clone the object/array deeply by its value (reference decoupled)
 * @param {object|array} source             - referencing object
 * @return {object|array}                   - cloned object which is allocated at different memory
 */
const cloneDeep = (source) => {
  if (!['Object', 'Array'].includes(checkToStringTag(source))) throw new TypeError('Invalid arguments as input.');
  return mergeDeep(checkToStringTag(source, 'Array') ? [] : {}, source, { mutate: true });
};


/**
 * merge two object recursively                                                                                         // note: this function can not copy getter/setter properties
 * @param {object} target                   - object to be operated
 * @param {object|array} source             - referencing object
 * @param {boolean} [mutate = false]        - mutation setting
 * @return {object}                         - the merged object
 */
const mergeDeep = (target, source, { mutate = false } = {}) => {
  const worker = mutate === true ? target : cloneDeep(target);

  // non-tail-call recursion (parallel)
  const mergeRecursion = (obj, src) => {
    const srcKeys = Reflect.ownKeys(src);
    const objKeys = Reflect.ownKeys(obj);
    for (let i = srcKeys.length - 1, currentKey = srcKeys[i]; i > -1; currentKey = srcKeys[i -= 1]) {
      if (checkToStringTag(src[currentKey], 'Object')) {
        if (!objKeys.includes(currentKey)) obj[currentKey] = {};
        mergeRecursion(obj[currentKey], src[currentKey]);
      } else obj[currentKey] = src[currentKey];
    }
  };

  mergeRecursion(worker, source);
  return worker;
};


/**
 * assigned the value to an object by path recursively                                                                  // note: (1) can be set to mutable; (2) value could be 0{number}
 * @param {object} target                   - object to be operated
 * @param {string|array} path               - assigning object path
 * @param {*} [value]                       - value to be assigned (by reference)
 * @param {boolean} [mutate = false]        - mutation setting
 * @return {object}                         - the assigned object
 */
const assignDeep = (target, path, value, { mutate = false } = {}) => {
  const worker = mutate === true ? target : cloneDeep(target);
  const pathStack = checkToStringTag(path, 'String') ? parseObjPath(path) : path;

  // tail-call recursion (single-file)
  const assignRecursion = (obj, keys) => {
    if (keys.length === 1) obj[keys[0]] = value;
    else {
      if (obj[keys[0]] === undefined) obj[keys[0]] = {};
      return assignRecursion(obj[keys[0]], keys.slice(1), value);
    }
  };

  assignRecursion(worker, pathStack, value);
  return worker;
};


/**
 * frozen the target and its property deeply
 * @param {object|array} target             - object to be operated
 * @param {boolean} [mutate = false]        - mutation setting
 * @return {object|array}                   - the frozen object/array
 */
const freezeDeep = (target, { mutate = false } = {}) => {
  const worker = mutate === true ? target : cloneDeep(target);

  // non-tail-call recursion (parallel)
  const freezeRecursion = (obj) => {
    if (['Object', 'Array'].includes(checkToStringTag(obj))) {
      const objKeys = Reflect.ownKeys(obj);
      for (let i = objKeys.length - 1; i > -1; i -= 1) freezeRecursion(obj[objKeys[i]]);
      Object.freeze(obj);
    }
  };

  freezeRecursion(worker);
  return worker;
};


/**
 * burst array in a nested object based on a given position in all array
 * @param {object} target                   - object to be operated
 * @param {boolean} [mutate = false]        - mutation setting
 * @param {number} [position = -1]          - position in the array (0 = first-one-win; -1 = last-one-win)
 * @return {object}                         - the resulted object
 */
const burstArrayDeep = (target, { mutate = false, position = -1 } = {}) => {
  const worker = mutate === true ? target : cloneDeep(target);
  const index = Number(position);

  // non-tail-call recursion (parallel)
  const burstArrayRecursion = (obj) => {
    const keys = Object.keys(obj);
    for (let i = keys.length - 1, key = keys[i]; i > -1; key = keys[i -= 1]) {
      const type = checkToStringTag(obj[key]);
      if (type === 'Array') obj[key] = obj[key][index < 0 ? obj[key].length + index : index];
      if (type === 'Object') burstArrayRecursion(obj[key]);
    }
  };

  burstArrayRecursion(worker);
  return worker;
};


/**
 * (decorator) proxyfy the object for allowing case-insensitive access
 * @param {object} obj                      - object to be delegated
 * @param {boolean} [reverse = true]        - reverse the inspection direction
 * @return {object}                         - the resulted proxy
 */
const createCaseInsensitiveProxy = (obj, { reverse = true } = {}) => {
  if (!checkToStringTag(obj, 'Object')) throw new TypeError('Invalid arguments as input.');
  return new Proxy(obj, {
    get: (target, name) => {
      if (!checkToStringTag(name, 'String')) return Reflect.get(target, name);
      if (reverse === false) return target[Object.keys(target).find(key => key.toLowerCase() === name.toLowerCase())];
      return target[Object.keys(target).reverse().find(key => key.toLowerCase() === name.toLowerCase())];
    },
  });
};


// exports
module.exports = {
  hasOwnKey,
  cloneDeep,
  mergeDeep,
  assignDeep,
  freezeDeep,
  burstArrayDeep,
  createCaseInsensitiveProxy,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/controllers/utilities/string.js":
/*!****************************************************!*\
  !*** ./src/server/controllers/utilities/string.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-bitwise */
const { ObjectId } = __webpack_require__(/*! mongodb */ "mongodb");


/**
 * check the object type with `Object.prototype.toString`
 * @param {object} target                   - object to be checked
 * @param {string} [str]                    - name to be matched (case insensitive)
 * @return {(boolean|string)}               - if no name given, the brand name of the object would be returned
 */
const checkToStringTag = (target, str) => {
  const name = (obj) => Object.prototype.toString.call(obj).slice(8, -1);
  if (str && name(str).toLowerCase() !== 'string') throw new TypeError('Second argument is not a string.');
  if (str) return name(target).toLowerCase() === str.toLowerCase();
  return name(target);
};


/**
 * convert string to kebabCase
 * @param {string} str                      - any arbitrary string
 * @return {string|null}                    - kebabCased string
 */
const toKebabCase = (str) => {
  return !checkToStringTag(str, 'String') || !str ? null : str
    .replace(/([a-z])([A-Z])/g, '$1-$2')                                                                                // handle CamelCase
    .replace(/[`'":;,.?!@#$%^&*_=~(){}<>/\\\[\]\-\+\|\s]+/g, '-')                                                       // normalize special characters
    .replace(/(-[A-Z])([A-Z][a-z])/g, '$1-$2')                                                                          // handle signal words in CamelCase
    .replace(/^-+|-+$/g, '')                                                                                            // cleanup endpoints
    .toLowerCase();
};


/**
 * convert string to capitalize sentence
 * @param {string} str                      - any arbitrary string
 * @return {string|null}                    - capitalized string
 */
const toCapitalized = (str) => {
  return !checkToStringTag(str, 'String') || !str  ? null : str.split(' ')
    .map(subStr => subStr.charAt(0).toUpperCase() + subStr.slice(1)).join(' ');
};


/**
 * convert matched context to HTML entity                                                                               // note: this method allows `null` or `undefined` argument
 * @param {string} str                      - any arbitrary string
 * @return {string|null}                    - escaped string, only key HTML entities are escaped
 */
const toEscapedChars = (str) => {
  const charMap = {
    '=': '&#61;',
    "'": '&#39;',
    '"': '&#34;',
    '`': '&#96;',
    '.': '&#46;',
    ',': '&#44;',
    ':': '&#58;',
    ';': '&#59;',
    '<': '&#60;',
    '(': '&#40;',
    '[': '&#91;',
    '{': '&#123;',
  };
  return !checkToStringTag(str, 'String') || !str  ? null : str.replace(/[='"`.,:;<([{]/g, char => charMap[char]);
};


/**
 * parse Mongo ObjectId (hexadecimal)                                                                                   // todo: option to output ObjectId obj.
 * @param {string} str                      - any arbitrary string
 * @return {object|null}                    - hexadecimal Mongo `ObjectId` object
 */
const parseMongoObjectId = (str) => {
  const val = !checkToStringTag(str, 'String') || !str ? null : /(?:\=|\/|^)([a-f\d]{24})(?:\?|\/|$)/i.exec(str);
  return val ? ObjectId(val[1].toLowerCase()) : null;
};


/**
 * parse a string to object path array
 * @param {string} str                      - any arbitrary string
 * @return {array|null}                     - an array contains elements in ordered by nest keys (path)
 */
const parseObjPath = (str) => {
  return !checkToStringTag(str, 'String') || !str  ? null : str.match(/[a-zA-Z0-9$_]+/g);
};


/**
 * parse a given file path
 * @param {string} str                      - any arbitrary string
 * @return {object|null}                    - parsed result
 */
const parsePath = (str) => {
  if (!checkToStringTag(str, 'String') || !str) return null;

  // decode url
  const _decoded = decodeURIComponent(str);
  if (~_decoded.search(/([@#?]|\/\/).*\1/)) return null;

  // extract special components in a url
  const protocol  = _decoded.split('://').reverse()[1];
  const hash      = _decoded.includes('/') && _decoded.split('#')[1];
  const query     = _decoded.includes('/') && _decoded.replace(`#${hash}`, '').split('?')[1];

  // check location
  const _slug     = _decoded.replace(/^\w*:?\/\//, '').replace(`#${hash}`, '').replace(`?${query}`, '').split('/');
  const _host     = _decoded.includes('/') && _slug[0].includes('.') && _slug[0];

  // check port
  const port      = _host && _host.includes(':') && +_host.split(':')[1];
  if (Number.isNaN(port) || port < -1 || port > 65536) return null;

  // check base
  const base      = (_slug[_slug.length - 1] !== _host && _slug[_slug.length - 1]) || '';
  if (~base.search(/[@#?:]/)) return null;

  const username  = _host && _host.split('@').reverse()[1];
  const hostname  = _host && _host.replace(`${username}@`, '').split(':')[0];
  const ext       = base.includes('.') && base.split('.').reverse()[0];
  const dir       = `/${_slug.slice(_slug.indexOf(_host) + 1, _slug.indexOf(base)).join('/')}`.replace('//', '');

  // normalize result
  const result = { input: str, protocol, hostname, username, port, dir, base, ext, query, hash };
  for (let keys = Object.keys(result), i = keys.length - 1; i > -1; i -= 1) result[keys[i]] = result[keys[i]] || null;
  return result;
};


// exports
module.exports = {
  checkToStringTag,
  toKebabCase,
  toCapitalized,
  toEscapedChars,
  parseMongoObjectId,
  parseObjPath,
  parsePath,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/engines/router.js":
/*!**************************************!*\
  !*** ./src/server/engines/router.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Router } = __webpack_require__(/*! express */ "express");


// modules
const { _M_ } = __webpack_require__(/*! ../controllers/modules/ */ "./src/server/controllers/modules/index.js");
const { _U_ } = __webpack_require__(/*! ../controllers/utilities/ */ "./src/server/controllers/utilities/index.js");
const { exportHTML, exportJSON, rendererSymbols } = __webpack_require__(/*! ../controllers/handlers/exporter */ "./src/server/controllers/handlers/exporter.js");
const { initialReceptor, browserReceptor, APIReceptor } = __webpack_require__(/*! ../controllers/handlers/receptor */ "./src/server/controllers/handlers/receptor.js");


// helpers
/**
 * stack a queue from setting options
 * @param {object} option                   - setting options
 * @return {array}                          - ordering of the result is important
 */
const getRouterPlugins = (option) => {
  const queue = [];
  if (option.sensitive !== true) queue.push(_M_.caseInsensitiveQueryProxy);
  if (option.crawler === false) queue.push(_M_.noCrawlerHeader);
  if (option.cache === false) queue.push(_M_.noStoreCacheHeader);
  return [...new Set(queue)];
};


/**
 * compose an ordered, unique middleware firing chain
 * @param {string} mode                     - routing mode
 * @param {array|function} main             - the main controlling logic
 * @param {object} hooker                   - pre/post hooked middleware on the device
 * @param {array} access                    - accessing group defined in router permission
 * @param {object} option                   - router settings
 * @return {array}
 */
const getRouterStacks = (mode, main, hooker, access, option) => {
  const checkpoint = access ? !access.includes('public') ? _M_.isSignedIn : [] : [];
  const plugins = getRouterPlugins(option);
  const titleModifier = mode === 'HTML' && option.title ? _M_.modifyHTMLTitleTag(option.title) : [];
  const exporter = mode === 'HTML' ? exportHTML(option) : exportJSON(option);
  const chain = [checkpoint, plugins, hooker.pre, titleModifier, main, hooker.post, exporter];
  return _U_.express.wrapAsync([...new Set([].concat(...chain))]);
};


class Device {
  /**
   * construct a routing device contains information and methods in assembling routing middleware
   * @constructor
   * @param {array} rules = []              - an array that contains routing rule objects
   * @param {object} [option]               - (see express.Router() API)
   */
  constructor(rules = [], option = {}) {
    this._baseOption = _U_.object.freezeDeep(option);
    this._baseStack = new Set();
    this._setting = {};
    this._hook = { pre: [], post: [] };
    this.rules = _U_.object.freezeDeep(rules);
  }

  /**
   * getter of the Device setting, handling the setter duty via a Proxy
   * @return {object}                       - stored read-only device setting
   */
  get setting() {
    return new Proxy(this._setting, {
      set: (setting, option, value) => {
        if (option === 'title') this._hook.pre = this._hook.pre.concat(_M_.modifyHTMLTitleTag(value));
        else setting[option] = value;
        return true;
      },
    });
  }

  /**
   * setter of the Device setting, triggering a series of redirection of its getter pair
   * @param {object} options                - device specific setting
   */
  set setting(options) {
    Object.keys(options).forEach(key => {
      this.setting[key] = options[key];
    });
  }

  /**
   * middleware attaching (populating upon the device level, spreading on the whole route path afterward)
   * @param {function} fn                   - middleware to be shared
   * @return {Device}
   */
  use(fn) {
    this._baseStack.add(fn);
    return this;
  }

  /**
   * middleware hooking (explicitly populating into individual routing method)
   * @param {string} tag                    - position tag of the hook
   * @param {function|[function]} fn        - middleware to be staked
   * @return {Device}
   */
  hook(tag, fn) {
    if (['pre', 'post'].includes(tag)) this._hook[tag] = this._hook[tag].concat(fn);
    return this;
  }

  /**
   * assemble middleware from the device
   * @param {string} mode
   * @return {function}                     - middleware assembly (device)
   */
  exec(mode) {
    if (!['HTML', 'API'].includes(mode)) throw ReferenceError(`Received ${mode} as an invalid mode.`);
    const matrix = this.rules.filter(({ setting = {} }) => (mode === 'API' ? setting.servingAPI : true));

    // create router
    const router = new Router(this._baseOption);
    if (this._baseStack.size) router.use(...this._baseStack);

    // register router
    matrix.forEach(({ route, alias, controller, setting = {}, permission = this.permission || {} }) => {
      const methodKeys = setting.method ? [setting.method] : Object.keys(controller).sort().reverse();
      const options = { ...this.setting, ...setting };
      for (let i = methodKeys.length - 1, method = methodKeys[i]; i > -1; method = methodKeys[i -= 1]) {
        if (method === 'alias' && !alias) throw new ReferenceError('Parameter "alias" have to be provided.');
        const path = method === 'alias' ? alias : route;
        const httpMethod = method === 'alias' ? 'get' : method.toLowerCase();
        const access = httpMethod === 'get' ? permission.access : permission.change;
        router[httpMethod](path, getRouterStacks(mode, controller[method], this._hook, access, options));
      }
    });

    // expose router
    return router;
  }

  /**
   * assemble middleware from the device cluster
   * @param {string} mode                   - assemble mode, accept 'HTML' or 'API'
   * @param {[string, object]} clusterPairs - routing path and device pair
   * @return {function}                     - middleware assembly (device cluster)
   */
  static exec(mode, clusterPairs) {
    const router = new Router({});
    router.use(initialReceptor);
    router.use(mode === 'HTML' ? browserReceptor : APIReceptor);
    clusterPairs.forEach(([path, device]) => router.use(path, device.exec(mode)));
    return router;
  }

  /**
   * reference of available renderer Symbols
   * @return {Symbol}                       - shortcut for accessing renderer symbols
   */
  static get renderer() {
    return rendererSymbols;
  }
}


// exports
module.exports = {
  Device,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    getRouterPlugins,
    getRouterStacks,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/engines/view.js":
/*!************************************!*\
  !*** ./src/server/engines/view.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { matchPath } = __webpack_require__(/*! react-router-dom */ "react-router-dom");
const { renderToString } = __webpack_require__(/*! react-dom/server */ "react-dom/server");
const { routers } = __webpack_require__(/*! ../../app/routers/ */ "./src/app/routers/index.jsx");
const { renderServer } = __webpack_require__(/*! ../../app/render */ "./src/app/render.jsx");


const template = ({ title, body, data } = {}) => (`
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>${title}</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" rel="stylesheet"
      integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="/static/stylesheets/style.css">
    <script>window.__INIT__ = ${JSON.stringify(data)}</script>
    <script src="/static/scripts/bundle.js" defer></script>
  </head>
  <body>
    <div id="root">${body}</div>
  </body>
  </html>
`);


const serverSideRendering = async function serverSideRendering(req, res, next) {
  const activeRoute = routers.find(route => matchPath(req.path, route)) || {};
  const data = activeRoute.fetch ? await activeRoute.fetch(req.url) : {};
  const title = activeRoute.title || '';
  const markup = renderServer(req.url, data);
  res.send(template({ title, data, body: renderToString(markup) }));
};


// exports
module.exports = {
  serverSideRendering,
};

Object.defineProperty(module.exports, Symbol.for('__TEST__'), {
  value: {
    template,
    ...module.exports,
  },
});


/***/ }),

/***/ "./src/server/models/configs.js":
/*!**************************************!*\
  !*** ./src/server/models/configs.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable key-spacing */
const mongoose = __webpack_require__(/*! mongoose */ "mongoose");


// schema
const configsSchema  = new mongoose.Schema({
  initialized        : { type: Boolean, default: false },
  active             : { type: Boolean, default: false, unique: true },
  title              : { type: String, default: 'New Website' },
  description        : { type: String, default: 'n/a' },
  keywords           : { type: String, default: 'n/a' },
  sets: {
    imageTypes       : { type: [[String]], default: ['gif', 'jpe?g', 'png', 'svg', 'tiff', 'webp'] },
    language         : { type: String, default: 'en' },
    timezone         : { type: String, default: '' },
    timeFormat       : { type: String, default: '' },
    sort             : { type: String, default: '' },
    num              : { type: Number, default: 5 },
  },
}, {
  timestamps         : { createdAt: 'time._created', updatedAt: 'time._updated' },
  versionKey         : false,
});


// static methods
configsSchema.static('initConfig', async function configsSchema_initialize(app, cb) {
  const config = await this.findOne({ active: true });
  app.set('APP_CONFIG', config ? (await config.toObject()) : (await this.create({ active: true })).toObject());
  if (typeof cb === 'function') return cb();
});


configsSchema.static('updateConfig', async function configsSchema_updateConfig(app, doc, cb) {                          // todo: update lang (process.env)
  app.set('APP_CONFIG', (await this.findOneAndUpdate({ active: true }, doc, { new: true })).toObject());
  if (typeof cb === 'function') return cb();
});


// exports
module.exports = mongoose.model('settings', configsSchema);


/***/ }),

/***/ "./src/server/models/index.js":
/*!************************************!*\
  !*** ./src/server/models/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  ConfigsModel: __webpack_require__(/*! ./configs */ "./src/server/models/configs.js"),
  UsersModel: __webpack_require__(/*! ./users */ "./src/server/models/users.js"),
  PostsModel: __webpack_require__(/*! ./posts */ "./src/server/models/posts.js"),
  MediaModel: __webpack_require__(/*! ./media */ "./src/server/models/media.js"),
};


/***/ }),

/***/ "./src/server/models/media.js":
/*!************************************!*\
  !*** ./src/server/models/media.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable key-spacing */
const mongoose = __webpack_require__(/*! mongoose */ "mongoose");


// schema
const MediaSchema   = new mongoose.Schema({
  author: {
    _id: {
      type          : mongoose.Schema.Types.ObjectId,
      ref           : 'users',
    },
    nickname        : { type: String },
  },
  file: {
    name            : { type: String },
    path            : { type: String },
    ext             : { type: String },
  },
  title             : { type: String, trim: true, required: [true, 'is required'] },
  description       : { type: String, trim: true, required: [true, 'is required'] },
  category          : { type: String, lowercase: true },
  tag               : { type: String, lowercase: true },
}, {
  timestamps        : { createdAt: 'time.uploaded', updatedAt: 'time._updated' },
  versionKey        : '_revised',
});


// action hooks
MediaSchema.pre('findOneAndUpdate', function MediaSchema_pre_findOneAndUpdate() {
  this.findOneAndUpdate({}, { $inc: { _revised: 1 } });
});


// exports
module.exports = mongoose.model('media', MediaSchema);


/***/ }),

/***/ "./src/server/models/posts.js":
/*!************************************!*\
  !*** ./src/server/models/posts.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable key-spacing */
const mongoose = __webpack_require__(/*! mongoose */ "mongoose");
const { _U_ } = __webpack_require__(/*! ../controllers/utilities/ */ "./src/server/controllers/utilities/index.js");


// schema
const PostsSchema    = new mongoose.Schema({
  author: {
    _id: {
      type           : mongoose.Schema.Types.ObjectId,
      ref            : 'users',
    },
    nickname         : { type: String },
  },
  featured           : { type: String,                                                                                  // todo: featured by a video
    validate: {
      validator      : value => value !== undefined,
      message        : 'Invalid image URL',
    } },
  canonical          : { type: String, lowercase: true, unique: true },
  title              : { type: String, required: [true, 'is required'], trim: true },
  content            : { type: String, required: [true, 'is required'], trim: true },
  category           : { type: String, lowercase: true, default: 'unclassified' },
  tags               : { type: String, lowercase: true },
  state: {
    published        : { type: Boolean, required: true, default: true },
    protected        : { type: Boolean, required: true, default: false },                                               // todo: add pw
    hidden           : { type: Boolean, required: true, default: false },                                               // todo: add anti-robot HTML tag
    pinned           : { type: Boolean, required: true, default: false },
  },
  time: {
    _recycled        : { type: Date },
  },
}, {
  timestamps         : { createdAt: 'time._created', updatedAt: 'time._updated' },
  versionKey         : '_revised',
});


// indexes
PostsSchema
  .index({ tags : 1 })
  .index({ category : -1 })
  .index({ 'time._updated' : -1 })
  .index({ 'time._recycled' : 1 }, { expireAfterSeconds: 14 * 24 * 3600 * 1000 })
  .index({ title: 'text', content: 'text', category: 'text', tags : 'text' });


// action hooks
// // version counter
PostsSchema.pre('findOneAndUpdate', function PostsSchema_pre_findOneAndUpdate() {
  this.findOneAndUpdate({}, { $inc: { _revised: 1 } });
});


// // recycle setter
PostsSchema.pre('update', function PostsSchema_pre_update() {
  const _$update = this.getUpdate();
  if (_$update.$set['state.pended']   === true)   _$update.$set['state.published']  = false;                            // tofix: initial post ist not worked
  if (_$update.$set['state.recycled'] === true)   _$update.$set['time._recycled']   = Date.now();
  if (_$update.$set['state.recycled'] === false)  _$update.$set['time._recycled']   = null;
  if (_$update.$set['state.restored'] === true)   _$update.$set['time._recycled']   = null;
});


// // before saving
PostsSchema.pre('save', function PostsSchema_pre_save() {
  this.canonical = _U_.string.toKebabCase(this.title);                                                                  // tofix: duplicated key (e.g. /new, /edit, /edit_2)
});


// virtual property
PostsSchema.virtual('state.pended').get(function () {
  return !this.state.published;
});


PostsSchema.virtual('state.recycled').get(function () {
  return !!this.time._recycled;
});


PostsSchema.virtual('time._expired').get(function () {
  return this.time._recycled ? new Date(this.time._recycled.getTime() + (14 * 24 * 3600 * 1000)) : null;
});


// exports
module.exports = mongoose.model('posts', PostsSchema);


/***/ }),

/***/ "./src/server/models/users.js":
/*!************************************!*\
  !*** ./src/server/models/users.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/* eslint-disable key-spacing */
const mongoose = __webpack_require__(/*! mongoose */ "mongoose");
const validator = __webpack_require__(/*! validator */ "validator");
const passportLocalMongoose = __webpack_require__(/*! passport-local-mongoose */ "passport-local-mongoose");


// schema
const UsersSchema   = new mongoose.Schema({
  active            : { type: String, default: false },
  role              : { type: String, enum: ['admin', 'coordinator', 'editor'], default: 'editor' },
  username          : { type: String, unique: true, lowercase: true },
  email             : { type: String,
    unique          : true,
    required        : true,
    validate: {
      isAsync       : false,
      validator     : validator.isEmail,
      message       : 'Invalid email address',
    } },
  nickname          : { type: String },
  picture           : { type: String, default: '' },                                                                    // todo: added a validator
  info: {
    firstName       : { type: String, default: '', trim: true },
    lastName        : { type: String, default: '', trim: true },
    gender          : { type: String, enum: ['Male', 'Female', 'NA'], default: 'NA' },
    residency       : { type: String },
    timezone        : { type: String },
    birthday        : { type: Date },
  },
  time: {
    _signIn         : { type: Date },
    _changePassword : { type: Date },
  },
}, {
  timestamps        : { createdAt: 'time._registered', updatedAt: 'time._updated' },
  versionKey        : false,
  toJSON            : { virtuals: true },
});


// action hooks
// // nickname assignment (pre-hook)
UsersSchema.pre('save', function UsersSchema_pre_save() {
  if (this.nickname === undefined) this.nickname = `${this.info.firstName} ${this.info.lastName}`.trim();
});


// // auto-update all posts associated with the author in dark (pre-hook)
UsersSchema.pre('update', function UsersSchema_pre_update() {
  const _$update = this.getUpdate();
  if (_$update.$set.nickname !== _$update.$set._$nickname) {
    mongoose.connection.db.collection('posts').update(
      { 'author._id': this.getQuery()._id },
      { $set: { 'author.nickname': _$update.$set.nickname } },
      { multi: true },
    );
  }
});


// methods for documents
// // update the specified last time field
UsersSchema.methods.updateLastTimeLog = function UsersSchema_updateLastTimeLog(fieldName) {
  return mongoose.connection.db.collection('users').update(
    { _id: this._id },
    { $set: { [`time._${fieldName}`]: new Date(Date.now()) } },
  );
};


// // methods from third-party plugin (object method)
UsersSchema.plugin(passportLocalMongoose, {
  usernameField: 'email',
  usernameQueryFields: ['username'],
  selectFields: ['_id', 'email', 'nickname', 'picture', 'info', 'time'],
});


// virtual method for user-post association
// // to-use: UsersModel.findOne({}).populate({ path: 'posts', match: { 'time._recycled': { $eq: null } }}).exec();
UsersSchema.virtual('posts', {
  ref         : 'posts',
  localField  : '_id',
  foreignField: 'author._id',
});


// exports
module.exports = mongoose.model('users', UsersSchema);


/***/ }),

/***/ "./src/server/routers/auth.js":
/*!************************************!*\
  !*** ./src/server/routers/auth.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { usePassport } = __webpack_require__(/*! ../controllers/modules/ */ "./src/server/controllers/modules/index.js")._M_;
const { ClientException } = __webpack_require__(/*! ../controllers/utilities/ */ "./src/server/controllers/utilities/index.js")._U_.error;
const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");
const { auth } = __webpack_require__(/*! ../controllers/routers/ */ "./src/server/controllers/routers/index.js");


// device
const authRouter = new Device([
  {
    route: '/signup',
    controller: auth.signup,
    setting: {
      title: 'Sign Up',
      template: './__root__/account/signup',
    },
  },
  {
    route: '/signin',
    controller: auth.signin,
    setting: {
      title: 'Sign In',
      template: './__root__/account/signin',
    },
  },
  {
    route: '/signout',
    controller: auth.signout,
  },
]);


// settings
authRouter.hook('pre', usePassport);
authRouter.hook('post', (err, req, res, next) => {
  return next(new ClientException(err));
});


// exports
module.exports = authRouter;


/***/ }),

/***/ "./src/server/routers/blog.js":
/*!************************************!*\
  !*** ./src/server/routers/blog.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");
const { blog } = __webpack_require__(/*! ../controllers/routers/ */ "./src/server/controllers/routers/index.js");


// device
const blogRouter = new Device([
  {
    route: ['/edit', '/new'],
    controller: blog.edit,
    permission: {
      access: ['editor'],                                                                                               // todo: use Device.permission.ROLE_EDITOR
      change: ['editor'],
    },
    setting: {
      method: 'GET',
      template: './__root__/editor',
      title: 'New post',
    },
  },
  {
    alias: '/:canonical/edit',
    route: /^\/([a-f\d]{24})\/?\/edit\/?$/i,
    controller: blog.edit,
    permission: {
      access: ['owner'],
      change: ['owner'],
    },
    setting: {
      template: './__root__/editor',
      title: 'Edit post',
    },
  },
  {
    alias: '/:canonical',
    route: /^\/([a-f\d]{24})\/?$/i,
    controller: blog.post,
    permission: {
      access: ['public'],
      change: ['owner'],
    },
    setting: {
      template: './theme/blog/posts',
      servingAPI: true,
    },
  },
  {
    route: '/',
    controller: blog.list,
    permission: {
      access: ['public'],
      change: ['editor'],
    },
    setting: {
      template: './theme/blog/',
      renderer: Device.renderer.VIEW_POSTS_MULTIPLE,
      servingAPI: true,
    },
  },
]);


// settings
blogRouter.setting.renderer = Device.renderer.VIEW_POSTS_SINGLE;


// exports
module.exports = blogRouter;


/***/ }),

/***/ "./src/server/routers/home.js":
/*!************************************!*\
  !*** ./src/server/routers/home.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");
const { home } = __webpack_require__(/*! ../controllers/routers/ */ "./src/server/controllers/routers/index.js");
const { _M_ } = __webpack_require__(/*! ../controllers/modules/ */ "./src/server/controllers/modules/index.js");


// device
const homeRouter = new Device([
  {
    route: '/profile/edit',
    controller: home.profile,
    setting: {
      method: 'GET',
      title: 'Edit Your Profile',
      template: './__root__/home/profile/profile_editor',
    },
  },
  {
    route: '/profile',
    controller: home.profile,
    setting: {
      title: 'Profile',
      template: './__root__/home/profile/info',
      servingAPI: false,
    },
  },
  {
    route: '/security',
    controller: home.security,
    setting: {
      title: 'Change Password',
      template: './__root__/home/profile/security',
      servingAPI: false,
    },
  },
  {
    route: '/',
    controller: home.profile,
    setting: {
      method: 'GET',
      title: 'Home',
      template: './__root__/home/profile/info',
      servingAPI: false,
    },
  },
]);


// settings
homeRouter.setting = { title: 'Account', cache: false };
homeRouter.hook('pre', _M_.usePassport);
homeRouter.permission = {
  access: ['owner'],
  change: ['owner'],
};

// exports
module.exports = homeRouter;


/***/ }),

/***/ "./src/server/routers/index.js":
/*!*************************************!*\
  !*** ./src/server/routers/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");


// routers
const initRouter = __webpack_require__(/*! ./init */ "./src/server/routers/init.js");
const authRouter = __webpack_require__(/*! ./auth */ "./src/server/routers/auth.js");
const siteRouter = __webpack_require__(/*! ./site */ "./src/server/routers/site.js");
const homeRouter = __webpack_require__(/*! ./home */ "./src/server/routers/home.js");
const blogRouter = __webpack_require__(/*! ./blog */ "./src/server/routers/blog.js");
const pageRouter = __webpack_require__(/*! ./page */ "./src/server/routers/page.js");


// service
const routingService = (mode) => {
  return Device.exec(mode, [
    ['/', authRouter],
    ['/init', initRouter],
    ['/site', siteRouter],
    ['/home', homeRouter],
    ['/blog', blogRouter],
    ['/', pageRouter],
  ]);
};


// exports
module.exports = routingService;


/***/ }),

/***/ "./src/server/routers/init.js":
/*!************************************!*\
  !*** ./src/server/routers/init.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _M_: { usePassport } } = __webpack_require__(/*! ../controllers/modules/ */ "./src/server/controllers/modules/index.js");
const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");
const { init } = __webpack_require__(/*! ../controllers/routers/ */ "./src/server/controllers/routers/index.js");


// device
const initRouter = new Device([
  {
    route: '/',
    controller: init,
    permission: {
      access: ['public'],
      change: ['public'],
    },
    setting: {
      servingAPI: false,
      template: './__root__/init',
      title: { tag: 'App Initializer', extend: false },
    },
  },
]);


// exports
initRouter.hook('pre', usePassport);
initRouter.setting.init = true;
module.exports = initRouter;


/***/ }),

/***/ "./src/server/routers/page.js":
/*!************************************!*\
  !*** ./src/server/routers/page.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");
const { page } = __webpack_require__(/*! ../controllers/routers/ */ "./src/server/controllers/routers/index.js");


// device
const pageRouter = new Device([
  {
    route: '/search/:search',
    controller: page.search,
    setting: {
      template: './theme/search',
      renderer: Device.renderer.VIEW_POSTS_MULTIPLE,
      crawler: false,
      servingAPI: true,
    },
  },
  {
    route: '/:page/edit',
    controller: page.show,
    permission: {
      access: ['editor'],
    },
  },
  {
    route: '/:page',
    controller: page.edit,
    setting: {
      servingAPI: true,
    },
  },
  {
    route: '/',
    controller: page.root,
    setting: {
      template: './theme/',
    },
  },
]);


// settings
pageRouter.permission = {
  access: ['public'],                                                                                               // todo: use Device.permission.ROLE_EDITOR
  change: ['editor'],
};

// exports
module.exports = pageRouter;


/***/ }),

/***/ "./src/server/routers/site.js":
/*!************************************!*\
  !*** ./src/server/routers/site.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { Device } = __webpack_require__(/*! ../engines/router */ "./src/server/engines/router.js");
const { site } = __webpack_require__(/*! ../controllers/routers/ */ "./src/server/controllers/routers/index.js");


// device
const siteRouter = new Device([
  {
    route: '/configs',
    controller: site.configs,
    permission: {
      change: ['admin'],
    },
    setting: {
      title: 'Website Settings',
      template: './__root__/site/configs',
    },
  },
  {
    route: '/upload',
    controller: site.upload,
    setting: {
      title: 'Media Uploader',
      template: './__root__/site/upload',
    },
  },
  {
    route: '/stack/:collection',
    controller: site.stack,
    setting: {
      title: 'Stack',
      template: './__root__/site/stack/:collection',
      renderer: Device.renderer.VIEW_STACK,
      servingAPI: true,
    },
  },
  {
    route: '/',
    controller: site.root,
    setting: {
      title: 'Dashboard',
      template: './__root__/',
    },
  },
]);


// settings
siteRouter.setting = { title: 'Control', cache: false };
siteRouter.permission = {
  access: ['editor'],
  change: ['editor'],
};

// exports
module.exports = siteRouter;


/***/ }),

/***/ "./src/server/server.js":
/*!******************************!*\
  !*** ./src/server/server.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const fs = __webpack_require__(/*! fs */ "fs");
const http2 = __webpack_require__(/*! spdy */ "spdy");
const debug = __webpack_require__(/*! debug */ "debug")('OpenBox:server');
const app = __webpack_require__(/*! ./app */ "./src/server/app.js");
const { _U_: { string: { checkToStringTag } } } = __webpack_require__(/*! ./controllers/utilities/ */ "./src/server/controllers/utilities/index.js");


// helper functions
/** Normalize a port into a number, string, or false **/
const normalizePort = (val) => {
  const port = parseInt(val, 10);

  if (Number.isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
};


// server entity
/** Get port from environment and store in Express **/
const port = normalizePort(process.env.PORT || '3443');
app.set('port', port);


/** Get SSL credentials as options **/
const options = {
  key: fs.readFileSync(process.env.SSL_KEY, 'utf8'),
  cert: fs.readFileSync(process.env.SSL_CRT, 'utf8'),
};


/** Create HTTP2 server **/
const server = http2.createServer(options, app);


// events handler
/** Event listener for HTTP server "error" event **/
const onError = (error) => {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = checkToStringTag(port, 'String')
    ? `Pipe ${port}`
    : `Port ${port}`;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(`${bind} requires elevated privileges`);
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(`${bind} is already in use`);
      process.exit(1);
      break;
    default: {
      throw error;
    }
  }
};


/** Event listener for HTTP server "listening" event **/
const onListening = () => {
  const addr = server.address();
  const bind = checkToStringTag(addr, 'String')
    ? `pipe ${addr}`
    : `port ${addr.port}`;
  debug(`Listening on ${bind}`);
};


// events listener
/** Listen on provided port, on all network interfaces **/
server.listen(port);
server.on('error', onError);
server.on('listening', onListening);


/** Event listener for 'unhandledRejection' event **/
process.on('unhandledRejection', (err) => console.log('Unhandled Promise Rejection:\n', err.stack));


/***/ }),

/***/ "./src/server/services/error.js":
/*!**************************************!*\
  !*** ./src/server/services/error.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const { _U_: { error: { HttpException } } } = __webpack_require__(/*! ../controllers/utilities/ */ "./src/server/controllers/utilities/index.js");
const { exceptionHandler } = __webpack_require__(/*! ../controllers/handlers/error */ "./src/server/controllers/handlers/error.js");


const errorHandlingAgent = app => {
  app.use('*', (req, res, next) => next(new HttpException(404)));
  app.use(exceptionHandler);
  app.use((err, req, res, next) => {
    console.log(err);
    res.sendStatus(500);
  });
};


// exports
module.exports = errorHandlingAgent;


/***/ }),

/***/ "./src/server/services/security.js":
/*!*****************************************!*\
  !*** ./src/server/services/security.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class ContentSecurityPolicy {
  constructor() {
    this.whitelist = [];
  }

  addToWhitelist(src, domain) {
    this.whitelist.push([src, domain]);
    return this;
  }

  getTrustedDomains(src) {
    return this.whitelist.filter(i => i[0].includes(src)).map(j => j[1]).join(' ');
  }

  rules() {
    const RuleMaps  = {
      'default-src': '\'self\'',
      'script-src': `'self' 'unsafe-inline' ${this.getTrustedDomains('script')}`,
      'style-src': `'self' 'unsafe-inline' ${this.getTrustedDomains('style')}`,
      'font-src': `${this.getTrustedDomains('font')}`,
      'img-src': '*',
      'frame-src': '\'none\'',
      'object-src': '\'none\'',
    };
    return Object.entries(RuleMaps).map(i => i.join(' ')).join('; ');
  }
}


const securityHeaderAgent = (app) => {
  const CSPConfigs = new ContentSecurityPolicy();
  CSPConfigs.addToWhitelist('script, style, font', 'https://stackpath.bootstrapcdn.com/');
  CSPConfigs.addToWhitelist('script, style', 'https://cdnjs.cloudflare.com/');
  CSPConfigs.addToWhitelist('script', 'https://code.jquery.com/');

  app.set('x-powered-by', false);
  app.use((req, res, next) => {
    res.set({
      'Content-Security-Policy': CSPConfigs.rules(),
      'Cache-Control': 'max-age=0',
      'X-XSS-Protection': '1; mode=block',
      'X-Frame-Options': 'DENY',
    });
    return next();
  });
};


// exports
module.exports = securityHeaderAgent;


/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("body-parser");

/***/ }),

/***/ "busboy":
/*!*************************!*\
  !*** external "busboy" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("busboy");

/***/ }),

/***/ "connect-flash":
/*!********************************!*\
  !*** external "connect-flash" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("connect-flash");

/***/ }),

/***/ "connect-mongo":
/*!********************************!*\
  !*** external "connect-mongo" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("connect-mongo");

/***/ }),

/***/ "debug":
/*!************************!*\
  !*** external "debug" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("express");

/***/ }),

/***/ "express-session":
/*!**********************************!*\
  !*** external "express-session" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("express-session");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mongodb");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("mongoose");

/***/ }),

/***/ "morgan":
/*!*************************!*\
  !*** external "morgan" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("morgan");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),

/***/ "passport":
/*!***************************!*\
  !*** external "passport" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("passport");

/***/ }),

/***/ "passport-local-mongoose":
/*!******************************************!*\
  !*** external "passport-local-mongoose" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("passport-local-mongoose");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "qs":
/*!*********************!*\
  !*** external "qs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("qs");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),

/***/ "react-dom/server":
/*!***********************************!*\
  !*** external "react-dom/server" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-dom/server");

/***/ }),

/***/ "react-router-dom":
/*!***********************************!*\
  !*** external "react-router-dom" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("react-router-dom");

/***/ }),

/***/ "serve-favicon":
/*!********************************!*\
  !*** external "serve-favicon" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("serve-favicon");

/***/ }),

/***/ "spdy":
/*!***********************!*\
  !*** external "spdy" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("spdy");

/***/ }),

/***/ "validator":
/*!****************************!*\
  !*** external "validator" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("validator");

/***/ })

/******/ });